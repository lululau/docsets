<!DOCTYPE html>
<html>
  <head>
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type' />
    <meta content='A Ruby ODM for MongoDB' name='description' />
    <meta content='mongoid, mongodb, ruby, rails, odm, durran jordan' name='keywords' />
    <!--[if lt IE 9]>
  <script src='http://html5shiv.googlecode.com/svn/trunk/html5.js'></script>
<![endif]-->
<meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0' name='viewport' />
<link href="../../../stylesheets/bootstrap.min.css" media="screen" rel="stylesheet" type="text/css" />
<link href="../../../stylesheets/bootstrap-responsive.min.css" media="screen" rel="stylesheet" type="text/css" />
<link href="../../../stylesheets/mongoid.css" media="screen" rel="stylesheet" type="text/css" />
<link href="../../../stylesheets/mongoid-coderay.css" media="screen" rel="stylesheet" type="text/css" />
<script src="../../../javascripts/jquery-1.8.1.min.js" type="text/javascript"></script>
<script src="../../../javascripts/bootstrap-dropdown.js" type="text/javascript"></script>
<script src="../../../javascripts/bootstrap-scrollspy.js" type="text/javascript"></script>
<script src="../../../javascripts/bootstrap-tooltip.js" type="text/javascript"></script>
<script src="../../../javascripts/mongoid.js" type="text/javascript"></script>
<title>Mongoid: Relations</title>
  </head>
  <body data-offset='100' data-spy='scroll-spy' data-target='.page-nav'>
    <div class='mongoid' id='header'>
      <div class='navbar navbar-inverse navbar-fixed-top'>
        <div class='navbar-inner'>
          <div class='container'>
            <ul class='nav'>
              <li class='link'>
                            <a title="Mongoid" href="../../../en/mongoid/"><img src="../../../images/mongoid-logo-small-green.png" />
                </a>
    
              </li>
              <li class='link'>
                            <a title="Origin" href="../../../en/origin/"><img src="../../../images/origin-logo-small-white.png" />
                </a>
    
              </li>
              <li class='link'>
                            <a title="Moped" href="../../../en/moped/"><img src="../../../images/moped-logo-small-white.png" />
                </a>
    
              </li>
            </ul>
            <div class='logo-text'>
              mongoid
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id='navigation'>
      <div class='subnav'>
        <div class='container'>
          <ul class='nav nav-pills mongoid'>
            <li><a href="../../../en/mongoid/">HOME</a></li>
            <li class='dropdown' id='docs'>
              <a class='dropdown-toggle' data-toggle='dropdown' href='#docs'>
                DOCS
                <b class='caret'></b>
              </a>
              <ul class='dropdown-menu'>
                <li><a href="../../../en/mongoid/docs/installation.html">Installation</a></li>
                <li><a href="../../../en/mongoid/docs/documents.html">Documents</a></li>
                <li><a href="../../../en/mongoid/docs/persistence.html">Persistence</a></li>
                <li><a href="../../../en/mongoid/docs/querying.html">Querying</a></li>
                <li><a href="../../../en/mongoid/docs/relations.html">Relations</a></li>
                <li><a href="../../../en/mongoid/docs/nested_attributes.html">Nested Attributes</a></li>
                <li><a href="../../../en/mongoid/docs/identity_map.html">Identity Map</a></li>
                <li><a href="../../../en/mongoid/docs/callbacks.html">Callbacks</a></li>
                <li><a href="../../../en/mongoid/docs/validation.html">Validation</a></li>
                <li><a href="../../../en/mongoid/docs/indexing.html">Indexing</a></li>
                <li><a href="../../../en/mongoid/docs/rails.html">Rails</a></li>
                <li><a href="../../../en/mongoid/docs/extras.html">Extras</a></li>
                <li><a href="../../../en/mongoid/docs/upgrading.html">Upgrading</a></li>
                <li><a href="../../../en/mongoid/docs/contributing.html">Contributing</a></li>
                <li><a href="../../../en/mongoid/docs/performance.html">Performance</a></li>
                <li><a href="../../../en/mongoid/docs/tips.html">Tips/FAQs</a></li>
              </ul>
            </li>
            <li><a href="../../../en/mongoid/links.html">LINKS</a></li>
            <li><a href="../../../en/mongoid/donate.html">DONATE</a></li>
          </ul>
        </div>
      </div>
    </div>
    <div id='content'>
      <div class='container'>
        <h1>Relations</h1>
<p>
  Relations are associations between one model and another in the domain
  and in the database. Embedded relations describe documents who are
  stored inside other documents in the database. Referenced relations
  describe documents that reference documents in another collection by
  storing foreign key data (usually an id) about the other document
  in itself.
</p>
<p>
  All relation objects in Mongoid are proxies to the actual document or
  documents themselves, which provide extra functionality for accessing,
  replacing, appending and persisting.
</p>
<div class='page-nav'>
  <div class='container'>
    <ul class='nav nav-pills'>
      <li><a href="#common">Common Behaviour</a></li>
      <li><a href="#metadata">Metadata</a></li>
      <li><a href="#embeds_one">Embedded 1-1</a></li>
      <li><a href="#embeds_many">Embedded 1-n</a></li>
      <li><a href="#has_one">Referenced 1-1</a></li>
      <li><a href="#has_many">Referenced 1-n</a></li>
      <li><a href="#has_and_belongs_to_many">Referenced n-n</a></li>
    </ul>
  </div>
</div>
<section id='common'>
  <h2>Common Behaviour</h2>
  <h3>Attributes</h3>
  <p>
    All relations contain a <code>target</code>, which is the proxied document
    or documents, a <code>base</code> which is the document the relation hangs
    off, and <code>metadata</code> which provides information about the relation.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Person</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_many <span class="symbol">:addresses</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;person.addresses = [ address ]&#x000A;person.addresses.target <span class="comment"># returns [ address ]</span>&#x000A;person.addresses.base <span class="comment"># returns person</span>&#x000A;person.addresses.metadata <span class="comment"># returns the metadata</span>&#x000A;</pre></div>
  </div>
  <h3>Extensions</h3>
  <p>
    All relations can have extensions, which provides a way to add
    application specific functionality to the relation. They are defined by
    providing a block to the relation definition.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Person</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_many <span class="symbol">:addresses</span> <span class="keyword">do</span>&#x000A;    <span class="keyword">def</span> <span class="function">find_by_country</span>(country)&#x000A;      where(country: country).first&#x000A;    <span class="keyword">end</span>&#x000A;    <span class="keyword">def</span> <span class="function">chinese</span>&#x000A;      <span class="instance-variable">@target</span>.select { |address| address.country == <span class="string"><span class="delimiter">&quot;</span><span class="content">China</span><span class="delimiter">&quot;</span></span>}&#x000A;    <span class="keyword">end</span>&#x000A;  <span class="keyword">end</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;person.addresses.find_by_country(<span class="string"><span class="delimiter">&quot;</span><span class="content">Mongolia</span><span class="delimiter">&quot;</span></span>) <span class="comment"># returns address</span>&#x000A;person.addresses.chinese <span class="comment"># returns [ address ]</span>&#x000A;</pre></div>
  </div>
  <h3>Custom Relation Names</h3>
  <p>
    You can name your relations whatever you like, but if the class cannot be
    inferred by Mongoid from the name, and neither can the opposite side you'll
    want to provide the macro with some additional options to tell Mongoid
    how to hook them up.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Lush</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_one <span class="symbol">:whiskey</span>, class_name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Drink</span><span class="delimiter">&quot;</span></span>, inverse_of: <span class="symbol">:alcoholic</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Drink</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embedded_in <span class="symbol">:alcoholic</span>, class_name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Lush</span><span class="delimiter">&quot;</span></span>, inverse_of: <span class="symbol">:whiskey</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
  </div>
  <h3>Validations</h3>
  <p>
    It is important to note that by default, Mongoid will validate the
    children of any relation that are loaded into memory via a
    <code>validates_associated</code>. The relations that this applies to are:
    <ul>
      <li><code>embeds_many</code></li>
      <li><code>embeds_one</code></li>
      <li><code>has_many</code></li>
      <li><code>has_one</code></li>
      <li><code>has_and_belongs_to_many</code></li>
    </ul>
  </p>
  <p>
    If you do not want this behavior, you may turn it off when defining
    the relation.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Person</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;&#x000A;  embeds_many <span class="symbol">:addresses</span>, validate: <span class="predefined-constant">false</span>&#x000A;  has_many <span class="symbol">:posts</span>, validate: <span class="predefined-constant">false</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
  </div>
  <h3>Polymorphism</h3>
  <p>
    When a child embedded document can belong to more than one type of parent
    document, you can tell Mongoid to support this by adding the <code>as</code>
    option to the definition on the parents, and the <code>polymorphic</code>
    option on the child. On the child object, an additional field will be
    stored that indicates the type of the parent.
  </p>
  <div class='well'>
    <table>
      <tr>
        <td class='achtung'><img src="../../../images/achtung.png" /></td>
        <td class='note'>
          <p>
            Polymorphic behavior is allowed on all relations with the
            exception of <code>has_and_belongs_to_many</code>.
          </p>
        </td>
      </tr>
    </table>
  </div>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_many <span class="symbol">:photos</span>, as: <span class="symbol">:photographic</span>&#x000A;  has_one <span class="symbol">:address</span>, as: <span class="symbol">:addressable</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Photo</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embedded_in <span class="symbol">:photographic</span>, polymorphic: <span class="predefined-constant">true</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Address</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  belongs_to <span class="symbol">:addressable</span>, polymorphic: <span class="predefined-constant">true</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
  </div>
  <h3>Cascading Callbacks</h3>
  <p>
    If you want the embedded document callbacks to fire when calling a persistence
    operation on its parent, you will need to provide the cascade callbacks
    option to the relation.
  </p>
  <div class='well'>
    <table>
      <tr>
        <td class='achtung'><img src="../../../images/achtung.png" /></td>
        <td class='note'>
          <p>
            Cascading callbacks is only available on <code>embeds_one</code>
            and <code>embeds_many</code> relations.
          </p>
        </td>
      </tr>
    </table>
  </div>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_many <span class="symbol">:albums</span>, cascade_callbacks: <span class="predefined-constant">true</span>&#x000A;  embeds_one <span class="symbol">:label</span>, cascade_callbacks: <span class="predefined-constant">true</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;band.save <span class="comment"># Fires all save callbacks on the band, albums, and label.</span>&#x000A;</pre></div>
  </div>
  <h3>Dependent Behaviour</h3>
  <p>
    You can provided dependent options to referenced associations to
    instruct Mongoid how to handle situations where one side of the
    relation is deleted, or is attempted to be deleted. The options
    are as follows:
  </p>
  <ul>
    <li><code>:delete</code>: Delete the child document.</li>
    <li><code>:destroy</code>: Destroy the child document.</li>
    <li><code>:nullify</code>: Orphan the child document.</li>
    <li><code>:restrict</code>: Raise an error if the child is not empty.</li>
  </ul>
  <div class='well'>
    <table>
      <tr>
        <td class='achtung'><img src="../../../images/achtung.png" /></td>
        <td class='note'>
          <p>Dependent options are only available on referenced relations.</p>
        </td>
      </tr>
    </table>
  </div>
  <p>
    The default behavior of each association when no dependent option
    is provided is to nullify.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  has_many <span class="symbol">:albums</span>, dependent: <span class="symbol">:delete</span>&#x000A;  belongs_to <span class="symbol">:label</span>, dependent: <span class="symbol">:nullify</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Album</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  belongs_to <span class="symbol">:band</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Label</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  has_many <span class="symbol">:bands</span>, dependent: <span class="symbol">:restrict</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;label = <span class="constant">Label</span>.first&#x000A;label.bands.push(<span class="constant">Band</span>.first)&#x000A;label.delete <span class="comment"># Raises an error since bands is not empty.</span>&#x000A;&#x000A;<span class="constant">Band</span>.first.delete <span class="comment"># Will delete all associated albums.</span>&#x000A;</pre></div>
  </div>
  <h3>Autosaving</h3>
  <p>
    One core difference between Mongoid and Active Record from a behavior
    standpoint is that Mongoid does not automatically save child relations
    for relational associations. This is for performance reasons.
  </p>
  <p>
    To enable an autosave on a relational association (embedded associations
    do not need this since they are actually part of the parent in the
    database) add the <code>autosave</code> option to the relation.
  </p>
  <div class='well'>
    <table>
      <tr>
        <td class='achtung'><img src="../../../images/achtung.png" /></td>
        <td class='note'>
          Note that autosave functionality will automatically be added to a
          relation when using <code>accepts_nested_attributes_for</code> or
          validating presence of the relation.
        </td>
      </tr>
    </table>
  </div>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  has_many <span class="symbol">:albums</span>, autosave: <span class="predefined-constant">true</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;band = <span class="constant">Band</span>.first&#x000A;band.albums.build(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">101</span><span class="delimiter">&quot;</span></span>)&#x000A;band.save <span class="comment">#=&gt; Will save the album as well.</span>&#x000A;</pre></div>
  </div>
  <h3>Recursive Embedding</h3>
  <p>
    A document can recursively embed itself using
    <code>recursively_embeds_one</code> or <code>recursively_embeds_many</code>,
    which provides accessors for the parent and children via <code>parent_</code>
    and <code>child_</code> methods.
  </p>
  <div class='well'>
    <table>
      <tr>
        <td class='achtung'><img src="../../../images/achtung.png" /></td>
        <td class='note'>
          <p>Recursive options are only available on embedded relations.</p>
        </td>
      </tr>
    </table>
  </div>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Tag</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  recursively_embeds_many&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;root = <span class="constant">Tag</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">programming</span><span class="delimiter">&quot;</span></span>)&#x000A;child_one = root.child_tags.build&#x000A;child_two = root.child_tags.build&#x000A;&#x000A;root.child_tags <span class="comment"># [ child_one, child_two ]</span>&#x000A;child_one.parent_tag <span class="comment"># [ root ]</span>&#x000A;child_two.parent_tag <span class="comment"># [ root ]</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Node</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  recursively_embeds_one&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;root = <span class="constant">Node</span>.new&#x000A;child = <span class="constant">Node</span>.new&#x000A;root.child_node = child&#x000A;&#x000A;root.child <span class="comment"># child</span>&#x000A;child.parent_node <span class="comment"># root</span>&#x000A;</pre></div>
  </div>
  <h3>Existence Predicates</h3>
  <p>
    All relations have existence predicates on them in the form of
    <code>name?</code> and <code>has_name?</code> to check if the relation
    is blank.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_one <span class="symbol">:label</span>&#x000A;  embeds_many <span class="symbol">:albums</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;band.label?&#x000A;band.has_label?&#x000A;band.albums?&#x000A;band.has_albums?&#x000A;</pre></div>
  </div>
  <h3>Autobuilding</h3>
  <p>
    One to one relations (<code>embeds_one</code>, <code>has_one</code>) have
    an <code>autobuild</code> option which tells Mongoid to instantiate a
    new document when the relation is accessed and it is <code>nil</code>
  </p>
  <div class='well'>
    <table>
      <tr>
        <td class='achtung'><img src="../../../images/achtung.png" /></td>
        <td class='note'>
          <p>
            Existence predicates will not trigger an autobuild, so they will
            properly return <code>false</code> if the document is not
            present.
          </p>
        </td>
      </tr>
    </table>
  </div>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_one <span class="symbol">:label</span>, autobuild: <span class="predefined-constant">true</span>&#x000A;  has_one <span class="symbol">:producer</span>, autobuild: <span class="predefined-constant">true</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;band = <span class="constant">Band</span>.new&#x000A;band.label <span class="comment"># Returns a new empty label.</span>&#x000A;band.producer <span class="comment"># Returns a new empty producer.</span>&#x000A;</pre></div>
  </div>
  <h3>Touching</h3>
  <p>
    Any <code>belongs_to</code> relation, no matter where it hangs off from,
    can take an optional <code>:touch</code> option which will call the
    touch method on it and any parent relations with the option defined when
    the base document calls <code>#touch</code>.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  belongs_to <span class="symbol">:label</span>, touch: <span class="predefined-constant">true</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;band = <span class="constant">Band</span>.first&#x000A;band.touch <span class="comment">#=&gt; Calls touch on the parent label.</span>&#x000A;</pre></div>
  </div>
</section>
<section id='metadata'>
  <h2>Metadata</h2>
  <p>
    All relations in Mongoid contain metadata that holds information
    about the relation in question, and is a valuable tool for third
    party developers to use to extend Mongoid.
  </p>
  <p>
    You can access the metadata of the relation in a few different ways.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="comment"># Get the metadata for a named relation from the class or document.</span>&#x000A;<span class="constant">Model</span>.reflect_on_association(<span class="symbol">:relation_name</span>)&#x000A;model.reflect_on_association(<span class="symbol">:relation_name</span>)&#x000A;&#x000A;<span class="comment"># Get the metadata that the current object has in its relation.</span>&#x000A;model.metadata&#x000A;&#x000A;<span class="comment"># Get the metadata with a specific relation itself on a specific</span>&#x000A;<span class="comment"># document.</span>&#x000A;person.addresses.metadata&#x000A;</pre></div>
  </div>
  <h3>The Metadata Object</h3>
  <p>
    The metadata object itself contains more information than one might
    know what to do with, and is useful for developers of extensions
    to Mongoid.
  </p>
  <table class='table table-bordered table-striped'>
    <thead>
      <tr>
        <th>Method</th>
        <th>Description</th>
      </tr>
    </thead>
    <tr>
      <td><code>Metadata#as</code></td>
      <td>Returns the name of the parent to a polymorphic child.</td>
    </tr>
    <tr>
      <td><code>Metadata#as?</code></td>
      <td>Returns whether or not an as option exists.</td>
    </tr>
    <tr>
      <td><code>Metadata#autobuilding?</code></td>
      <td>Returns whether or not the relation is autobuilding.</td>
    </tr>
    <tr>
      <td><code>Metadata#autosaving?</code></td>
      <td>Returns whether or not the relation is autosaving.</td>
    </tr>
    <tr>
      <td><code>Metadata#cascading_callbacks?</code></td>
      <td>
        Returns whether the relation has callbacks cascaded down from
        the parent.
      </td>
    </tr>
    <tr>
      <td><code>Metadata#class_name</code></td>
      <td>Returns the class name of the proxied document.</td>
    </tr>
    <tr>
      <td><code>Metadata#cyclic?</code></td>
      <td>Returns whether the relation is a cyclic relation.</td>
    </tr>
    <tr>
      <td><code>Metadata#dependent</code></td>
      <td>Returns the relation's dependent option.</td>
    </tr>
    <tr>
      <td><code>Metadata#dependent?</code></td>
      <td>Returns whether the relation is a dependent relation.</td>
    </tr>
    <tr>
      <td><code>Metadata#destructive?</code></td>
      <td>Returns true if the relation has a dependent delete or destroy.</td>
    </tr>
    <tr>
      <td><code>Metadata#embedded?</code></td>
      <td>Returns whether the relation is embedded in another document.</td>
    </tr>
    <tr>
      <td><code>Metadata#forced_nil_inverse?</code></td>
      <td>Returns whether the relation has a nil inverse defined.</td>
    </tr>
    <tr>
      <td><code>Metadata#foreign_key</code></td>
      <td>Returns the name of the foreign key field.</td>
    </tr>
    <tr>
      <td><code>Metadata#foreign_key_check</code></td>
      <td>Returns the name of the foreign key field dirty check method.</td>
    </tr>
    <tr>
      <td><code>Metadata#foreign_key_setter</code></td>
      <td>Returns the name of the foreign key field setter.</td>
    </tr>
    <tr>
      <td><code>Metadata#indexed?</code></td>
      <td>Returns whether the foreign key is auto indexed.</td>
    </tr>
    <tr>
      <td><code>Metadata#inverses</code></td>
      <td>Returns the names of all inverse relation.</td>
    </tr>
    <tr>
      <td><code>Metadata#inverse</code></td>
      <td>Returns the name of a single inverse relation.</td>
    </tr>
    <tr>
      <td><code>Metadata#inverse_class_name</code></td>
      <td>Returns the class name of the relation on the inverse side.</td>
    </tr>
    <tr>
      <td><code>Metadata#inverse_foreign_key</code></td>
      <td>Returns the name of the foreign key field on the inverse side.</td>
    </tr>
    <tr>
      <td><code>Metadata#inverse_klass</code></td>
      <td>Returns the class of the relation on the inverse side.</td>
    </tr>
    <tr>
      <td><code>Metadata#inverse_metadata</code></td>
      <td>Returns the metadata of the relation on the inverse side.</td>
    </tr>
    <tr>
      <td><code>Metadata#inverse_of</code></td>
      <td>Returns the explicitly defined name of the inverse relation.</td>
    </tr>
    <tr>
      <td><code>Metadata#inverse_of?</code></td>
      <td>Returns whether an <code>inverse_of</code> option is defined.</td>
    </tr>
    <tr>
      <td><code>Metadata#inverse_setter</code></td>
      <td>Returns the name of the method used to set the inverse.</td>
    </tr>
    <tr>
      <td><code>Metadata#inverse_type</code></td>
      <td>Returns the name for the polymorphic type field of the inverse.</td>
    </tr>
    <tr>
      <td><code>Metadata#inverse_type_setter</code></td>
      <td>Returns the name for the polymorphic type field setter of the inverse.</td>
    </tr>
    <tr>
      <td><code>Metadata#key</code></td>
      <td>
        Returns the name of the field in the attributes hash to use to get
        the relation.
      </td>
    </tr>
    <tr>
      <td><code>Metadata#klass</code></td>
      <td>Returns the class of the proxied documents in the relation.</td>
    </tr>
    <tr>
      <td><code>Metadata#macro</code></td>
      <td>Returns the relation's macro.</td>
    </tr>
    <tr>
      <td><code>Metadata#name</code></td>
      <td>Returns the relation name.</td>
    </tr>
    <tr>
      <td><code>Metadata#options</code></td>
      <td>Returns self, for API compatibility with Active Record.</td>
    </tr>
    <tr>
      <td><code>Metadata#order</code></td>
      <td>Returns the custom sorting options on the relation.</td>
    </tr>
    <tr>
      <td><code>Metadata#order?</code></td>
      <td>Returns whether custom sorting options are set.</td>
    </tr>
    <tr>
      <td><code>Metadata#polymorphic?</code></td>
      <td>Returns whether the relation is polymorphic.</td>
    </tr>
    <tr>
      <td><code>Metadata#setter</code></td>
      <td>Returns the name of the field to set the relation.</td>
    </tr>
    <tr>
      <td><code>Metadata#store_as</code></td>
      <td>Returns the name of the attribute to store an embedded relation in.</td>
    </tr>
    <tr>
      <td><code>Metadata#touchable?</code></td>
      <td>Returns whether or not the relation has a touch option.</td>
    </tr>
    <tr>
      <td><code>Metadata#type</code></td>
      <td>Returns the name of the field to get the polymorphic type.</td>
    </tr>
    <tr>
      <td><code>Metadata#type_setter</code></td>
      <td>Returns the name of the field to set the polymorphic type.</td>
    </tr>
    <tr>
      <td><code>Metadata#validate?</code></td>
      <td>Returns whether the relation has an associated validation.</td>
    </tr>
    <tr>
      <td><code>Metadata#versioned?</code></td>
      <td>Returns whether the relation is an embedded version.</td>
    </tr>
  </table>
</section>
<section id='embeds_one'>
  <h2>Embedded 1-1</h2>
  <p>
    One to one relationships where the children are embedded in the parent
    document are defined using Mongoid's <code>embeds_one</code> and
    <code>embedded_in</code> macros.
  </p>
  <h3>Defining</h3>
  <p>
    The parent document of the relation should use the <code>embeds_one</code>
    macro to indicate is has 1 embedded child, where the document that
    is embedded uses <code>embedded_in</code>.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_one <span class="symbol">:label</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Label</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  field <span class="symbol">:name</span>, type: <span class="constant">String</span>&#x000A;  embedded_in <span class="symbol">:band</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
  </div>
  <div class='well'>
    <table>
      <tr>
        <td class='achtung'><img src="../../../images/achtung.png" /></td>
        <td class='note'>
          <p>
            Definitions are required on both sides to the relation in order
            for it to work properly.
          </p>
        </td>
      </tr>
    </table>
  </div>
  <h3>Storage</h3>
  <p>
    Documents that are embedded using the <code>embeds_one</code> macro are stored
    as a hash inside the parent in the parent's database collection.
  </p>
  <div class="CodeRay">
    <div class="code"><pre>{&#x000A;  <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e9</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="key"><span class="delimiter">&quot;</span><span class="content">label</span><span class="delimiter">&quot;</span></span> : {&#x000A;    <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e0</span><span class="delimiter">&quot;</span></span>),&#x000A;    <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">Mute</span><span class="delimiter">&quot;</span></span>,&#x000A;  }&#x000A;}&#x000A;</pre></div>
  </div>
  <p>
    You can optionally tell Mongoid to store the embedded document in a
    different attribute other than the name, by providing a <code>:store_as</code>
    option.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_one <span class="symbol">:label</span>, store_as: <span class="string"><span class="delimiter">&quot;</span><span class="content">lab</span><span class="delimiter">&quot;</span></span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
  </div>
  <h3>Operations</h3>
  <p>
    Once the relation is defined, the following operations are available, and
    the following table shows any database operations that are performed if
    applicable. The previously defined models will be used for example code.
  </p>
  <table class='table table-bordered table-striped'>
    <thead>
      <tr>
        <th>Operation</th>
        <th>Mongoid</th>
        <th>Moped</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class='doc'>
          <code>Model#{name}</code>
          <p class='doc'>
            <i>Get the embedded document.</i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.label</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}=</code>
          <p class='doc'>
            <i>
              Set the embedded document. If the parent document is persisted,
              then the child will be atomically saved immediately. If setting
              to <code>nil</code> then the child will be deleted.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.label = <span class="constant">Label</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Mute</span><span class="delimiter">&quot;</span></span>)&#x000A;&#x000A;band.label = <span class="predefined-constant">nil</span></pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$set</span><span class="delimiter">&quot;</span></span> =&gt; { label: { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Mute</span><span class="delimiter">&quot;</span></span> }}&#x000A;  )&#x000A;&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$unset</span><span class="delimiter">&quot;</span></span> =&gt; { label: <span class="predefined-constant">true</span> })&#x000A;</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{parent_name}</code>
          <p class='doc'>
            <i>
              Get the parent document from the child.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>label.band</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{parent_name}=</code>
          <p class='doc'>
            <i>
              Set the parent document from the child.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>label.band = <span class="constant">Band</span>.new</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#build_{name}</code>
          <p class='doc'>
            <i>
              Build a new document on the relation.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.build_label(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Mute</span><span class="delimiter">&quot;</span></span>)&#x000A;&#x000A;label.build_band(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Depeche Mode</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#create_{name}</code>
          <p class='doc'>
            <i>
              Create a new document from either side of the relation.
              This persists the child immediately if executing from the parent,
              and persists the entire tree if executed from the child.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.create_label(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Mute</span><span class="delimiter">&quot;</span></span>)&#x000A;&#x000A;label.create_band({&#x000A;  name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Depeche Mode</span><span class="delimiter">&quot;</span></span>&#x000A;})</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$set</span><span class="delimiter">&quot;</span></span> =&gt; { label: { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Mute</span><span class="delimiter">&quot;</span></span> }}&#x000A;  )&#x000A;&#x000A;collections[<span class="symbol">:bands</span>].&#x000A;  insert({&#x000A;    name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Depeche Mode</span><span class="delimiter">&quot;</span></span>,&#x000A;    label: { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Mute</span><span class="delimiter">&quot;</span></span> }&#x000A;  })&#x000A;</pre></div>
          </div>
        </td>
      </tr>
    </tbody>
  </table>
</section>
<section id='embeds_many'>
  <h2>Embedded 1-n</h2>
  <p>
    One to many relationships where the children are embedded in the parent
    document are defined using Mongoid's <code>embeds_many</code> and
    <code>embedded_in</code> macros.
  </p>
  <h3>Defining</h3>
  <p>
    The parent document of the relation should use the <code>embeds_many</code>
    macro to indicate it has <i>n</i> number of embedded children, where
    the document that is embedded uses <code>embedded_in</code>.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_many <span class="symbol">:albums</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Album</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  field <span class="symbol">:name</span>, type: <span class="constant">String</span>&#x000A;  embedded_in <span class="symbol">:band</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
  </div>
  <div class='well'>
    <table>
      <tr>
        <td class='achtung'><img src="../../../images/achtung.png" /></td>
        <td class='note'>
          <p>
            Definitions are required on both sides to the relation in order
            for it to work properly.
          </p>
        </td>
      </tr>
    </table>
  </div>
  <h3>Storage</h3>
  <p>
    Documents that are embedded using the <code>embeds_many</code> macro are stored
    as an array of hashes inside the parent in the parent's database
    collection.
  </p>
  <div class="CodeRay">
    <div class="code"><pre>{&#x000A;  <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e9</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="key"><span class="delimiter">&quot;</span><span class="content">albums</span><span class="delimiter">&quot;</span></span> : [&#x000A;    {&#x000A;      <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e0</span><span class="delimiter">&quot;</span></span>),&#x000A;      <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>,&#x000A;    }&#x000A;  ]&#x000A;}&#x000A;</pre></div>
  </div>
  <p>
    You can optionally tell Mongoid to store the embedded document in a
    different attribute other than the name, by providing a <code>:store_as</code>
    option.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  embeds_many <span class="symbol">:albums</span>, store_as: <span class="string"><span class="delimiter">&quot;</span><span class="content">albs</span><span class="delimiter">&quot;</span></span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
  </div>
  <h3>Operations</h3>
  <p>
    Once the relation is defined, the following operations are available, and
    the following table shows any database operations that are performed if
    applicable. The previously defined models will be used for example code.
  </p>
  <table class='table table-bordered table-striped'>
    <thead>
      <tr>
        <th>Operation</th>
        <th>Mongoid</th>
        <th>Moped</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class='doc'>
          <code>Model#{name}</code>
          <p class='doc'>
            <i>Get the embedded documents.</i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.albums</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}=</code>
          <p class='doc'>
            <i>
              Set the embedded documents. If the parent document is persisted,
              then the child will be atomically saved immediately. If setting
              to <code>nil</code> or <code>[]</code> then the children will be
              deleted.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.albums = [ <span class="constant">Album</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>) ]&#x000A;&#x000A;band.albums = <span class="predefined-constant">nil</span>&#x000A;band.albums = []</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$set</span><span class="delimiter">&quot;</span></span> =&gt; { albums: [{ name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }]}&#x000A;  )&#x000A;&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$unset</span><span class="delimiter">&quot;</span></span> =&gt; { albums: <span class="predefined-constant">true</span> })&#x000A;</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{parent_name}</code>
          <p class='doc'>
            <i>
              Get the parent document from any child.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>album.band</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{parent_name}=</code>
          <p class='doc'>
            <i>
              Set the parent document from a child.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>album.band = <span class="constant">Band</span>.new</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.<<</code><br/>
          <code>Model#{name}.push</code>
          <p class='doc'>
            <i>
              Push a new document onto the relation. If the parent is
              persisted, then the child documents will be automatically
              saved.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.albums &lt;&lt; <span class="constant">Album</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)&#x000A;band.albums.push(<span class="constant">Album</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>))</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$push</span><span class="delimiter">&quot;</span></span> =&gt; { albums: { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }}&#x000A;  )</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.concat</code>
          <p class='doc'>
            <i>
              Push multiple documents onto the relation. If the parent is
              persisted, then the child documents will be automatically
              saved.
              <b>Note that while batch operations limit the number
              of database calls to a single one for the new documents, it
              is in fact at least 2x slower from the Ruby side. This is due
              to the fact that 2 iterations over all documents must occur
              to ensure that all the before callbacks run before the db hit,
              and that all after callbacks have to wait until after.</b>
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.albums.concat(&#x000A;  <span class="constant">Album</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="constant">Album</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">101</span><span class="delimiter">&quot;</span></span>)&#x000A;)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$pushAll</span><span class="delimiter">&quot;</span></span> =&gt; {&#x000A;      albums: [{ name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }, { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">101</span><span class="delimiter">&quot;</span></span> }]&#x000A;    }&#x000A;  )</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.build</code><br/>
          <code>Model#{name}.new</code>
          <p class='doc'>
            <i>
              Build a new document in the relation with the provided
              attributes. Does not save the new document.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.albums.build(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)&#x000A;band.albums.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.create</code><br/>
          <code>Model#{name}.create!</code>
          <p class='doc'>
            <i>
              Create a new document in the relation with the provided
              attributes and saves. With the bang version an error will
              be raised if validation fails.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.albums.create(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)&#x000A;band.albums.create!(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$push</span><span class="delimiter">&quot;</span></span> =&gt; { albums: { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }}&#x000A;  )</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.clear</code><br/>
          <code>Model#{name}.delete_all</code>
          <p class='doc'>
            <i>
              Deletes all documents from the relation, without
              running any callbacks.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.albums.clear&#x000A;band.albums.delete_all&#x000A;band.albums.delete_all(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)&#x000A;band.albums.&#x000A;  where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>).delete_all</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$pullAll</span><span class="delimiter">&quot;</span></span> =&gt; { albums: [{ name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }]}&#x000A;  )</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.destroy_all</code>
          <p class='doc'>
            <i>
              Deletes all documents from the relation, while
              running the destroy callbacks.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.albums.destroy_all&#x000A;band.albums.destroy_all(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)&#x000A;band.albums.&#x000A;  where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>).destroy_all</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$pullAll</span><span class="delimiter">&quot;</span></span> =&gt; { albums: [{ name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }]}&#x000A;  )</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.delete</code>
          <p class='doc'>
            <i>
              Deletes the matching document from the relation.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.albums.delete(album)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$pull</span><span class="delimiter">&quot;</span></span> =&gt; { albums: { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }}&#x000A;  )</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.pop</code>
          <p class='doc'>
            <i>
              Deletes the provided number of documents, defaulting to 1.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.albums.pop&#x000A;band.albums.pop(<span class="integer">1</span>)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$pullAll</span><span class="delimiter">&quot;</span></span> =&gt; { albums: [{ name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }]}&#x000A;  )</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.find</code>
          <p class='doc'>
            <i>
              Return documents in the relation with matching ids. Will
              raise an error if all the ids are not found by default.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.albums.find(id)&#x000A;band.albums.find(id_one, id_two)</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.find_or_create_by</code>
          <p class='doc'>
            <i>
              Search for the document in the relation, and if not found
              create a newly persisted one.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.albums.&#x000A;  find_or_create_by(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(&#x000A;    <span class="string"><span class="delimiter">&quot;</span><span class="content">$push</span><span class="delimiter">&quot;</span></span> =&gt; { albums: { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span> }}&#x000A;  )</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.find_or_initialize_by</code>
          <p class='doc'>
            <i>
              Search for the document in the relation, and if not found
              add a new one.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.albums.&#x000A;  find_or_initialize_by(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.where</code>
          <p class='doc'>
            <i>
              Find matching documents in the relation. This can be any
              criteria method, not just where.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.albums.where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Violator</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.exists?</code>
          <p class='doc'>
            <i>
              Returns whether or not the relation has any documents.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.albums.exists?</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
    </tbody>
  </table>
</section>
<section id='has_one'>
  <h2>Referenced 1-1</h2>
  <p>
    One to one relationships where the children are referenced in the parent
    document are defined using Mongoid's <code>has_one</code> and
    <code>belongs_to</code> macros.
  </p>
  <h3>Defining</h3>
  <p>
    The parent document of the relation should use the <code>has_one</code>
    macro to indicate is has 1 referenced child, where the document that
    is referenced in it uses <code>belongs_to</code>.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  has_one <span class="symbol">:studio</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Studio</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  field <span class="symbol">:name</span>, type: <span class="constant">String</span>&#x000A;  belongs_to <span class="symbol">:band</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
  </div>
  <p>
    Definitions are required on both sides to the relation in order for it to
    work properly, unless one of the models is embedded.
  </p>
  <h3>Storage</h3>
  <p>
    When defining a relation of this nature, each document is stored in its
    respective collection, but the child document contains a "foreign key"
    reference to the parent.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="comment"># The parent band document.</span>&#x000A;{ <span class="string"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e9</span><span class="delimiter">&quot;</span></span>) }&#x000A;&#x000A;<span class="comment"># The child studio document.</span>&#x000A;{&#x000A;  <span class="string"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7f1</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="string"><span class="delimiter">&quot;</span><span class="content">band_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e9</span><span class="delimiter">&quot;</span></span>)&#x000A;}&#x000A;</pre></div>
  </div>
  <h3>Operations</h3>
  <p>
    Once the relation is defined, the following operations are available, and
    the following table shows any database operations that are performed if
    applicable. The previously defined models will be used for example code.
  </p>
  <table class='table table-bordered table-striped'>
    <thead>
      <tr>
        <th>Operation</th>
        <th>Mongoid</th>
        <th>Moped</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class='doc'>
          <code>Model#{name}</code>
          <p class='doc'>
            <i>Get the child document.</i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.studio</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}=</code>
          <p class='doc'>
            <i>
              Set the child document. If the parent document is persisted,
              then the child will be saved immediately. If setting
              to <code>nil</code> then the child will be deleted.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.studio = <span class="constant">Studio</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Abbey Road</span><span class="delimiter">&quot;</span></span>)&#x000A;&#x000A;band.studio = <span class="predefined-constant">nil</span></pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:studios</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Abbey Road</span><span class="delimiter">&quot;</span></span>, band_id: ... }&#x000A;)&#x000A;&#x000A;collections[<span class="symbol">:studios</span>].find(...).remove&#x000A;</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{parent_name}</code>
          <p class='doc'>
            <i>
              Get the parent document from the child.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>studio.band</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{parent_name}=</code>
          <p class='doc'>
            <i>
              Set the parent document from the child.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>studio.band = <span class="constant">Band</span>.new</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#build_{name}</code>
          <p class='doc'>
            <i>
              Build a new document on the relation. This does not save the
              new document.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.build_studio(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Abbey Road</span><span class="delimiter">&quot;</span></span>)&#x000A;&#x000A;studio.build_band(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Depeche Mode</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#create_{name}</code>
          <p class='doc'>
            <i>
              Create a new document from either side of the relation.
              This persists the child immediately if executing from the parent,
              and persists the parent if executed from the child.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.create_studio(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Abbey Road</span><span class="delimiter">&quot;</span></span>)&#x000A;&#x000A;studio.create_band(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Depeche Mode</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:studios</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Abbey Road</span><span class="delimiter">&quot;</span></span>, band_id: ... }&#x000A;)&#x000A;&#x000A;collections[<span class="symbol">:bands</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Depeche Mode</span><span class="delimiter">&quot;</span></span> }&#x000A;)&#x000A;</pre></div>
          </div>
        </td>
      </tr>
    </tbody>
  </table>
</section>
<section id='has_many'>
  <h2>Referenced 1-n</h2>
  <p>
    One to many relationships where the children are stored in a
    separate collection from the parent document are defined using
    Mongoid's <code>has_many</code> and <code>belongs_to</code> macros. This
    exhibits similar behavior to Active Record.
  </p>
  <h3>Defining</h3>
  <p>
    The parent document of the relation should use the <code>has_many</code>
    macro to indicate is has <i>n</i> number of referenced children, where
    the document that is referenced uses <code>belongs_to</code>.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  has_many <span class="symbol">:members</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Member</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  field <span class="symbol">:name</span>, type: <span class="constant">String</span>&#x000A;  belongs_to <span class="symbol">:band</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
  </div>
  <p>
    Definitions are required on both sides to the relation in order for it to
    work properly, unless one of the models is embedded.
  </p>
  <h3>Storage</h3>
  <p>
    When defining a relation of this nature, each document is stored in its
    respective collection, but the child document contains a "foreign key"
    reference to the parent.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="comment"># The parent band document.</span>&#x000A;{ <span class="string"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e9</span><span class="delimiter">&quot;</span></span>) }&#x000A;&#x000A;<span class="comment"># The child member document.</span>&#x000A;{&#x000A;  <span class="string"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7f1</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="string"><span class="delimiter">&quot;</span><span class="content">band_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e9</span><span class="delimiter">&quot;</span></span>)&#x000A;}&#x000A;</pre></div>
  </div>
  <h3>Operations</h3>
  <p>
    Once the relation is defined, the following operations are available, and
    the following table shows any database operations that are performed if
    applicable. The previously defined models will be used for example code.
  </p>
  <table class='table table-bordered table-striped'>
    <thead>
      <tr>
        <th>Operation</th>
        <th>Mongoid</th>
        <th>Moped</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class='doc'>
          <code>Model#{name}</code>
          <p class='doc'>
            <i>Get the related documents.</i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.members</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}=</code>
          <p class='doc'>
            <i>
              Set the related documents. If the parent document is persisted,
              then the child will be saved immediately. If setting
              to <code>nil</code> or <code>[]</code> then the children will be
              deleted.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.members = [ <span class="constant">Member</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>) ]&#x000A;&#x000A;band.members = <span class="predefined-constant">nil</span>&#x000A;band.members = []</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:members</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>, band_id: ... }&#x000A;)&#x000A;&#x000A;collections[<span class="symbol">:members</span>].find(...).remove</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}_ids</code>
          <p class='doc'>
            <i>Get the related document ids.</i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.member_ids</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}_ids=</code>
          <p class='doc'>
            <i>
              Set the related document ids.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.member_ids = [ id ]</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{parent_name}</code>
          <p class='doc'>
            <i>
              Get the parent document from any child.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>member.band</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{parent_name}=</code>
          <p class='doc'>
            <i>
              Set the parent document from a child.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>member.band = <span class="constant">Band</span>.new</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.<<</code><br/>
          <code>Model#{name}.push</code>
          <p class='doc'>
            <i>
              Push a new document onto the relation. If the parent is
              persisted, then the child documents will be automatically
              saved.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.members &lt;&lt; <span class="constant">Member</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)&#x000A;band.members.push(<span class="constant">Member</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>))</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:members</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>, band_id: ... }&#x000A;)</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.concat</code>
          <p class='doc'>
            <i>
              Push multiple documents onto the relation. If the parent is
              persisted, then the child documents will be automatically
              saved in a single batch.
              <b>Note that while batch operations limit the number
              of database calls to a single one for the new documents, it
              is in fact at least 2x slower from the Ruby side. This is due
              to the fact that 2 iterations over all documents must occur
              to ensure that all the before callbacks run before the db hit,
              and that all after callbacks have to wait until after.</b>
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.members.concat(&#x000A;  <span class="constant">Member</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="constant">Member</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Martin</span><span class="delimiter">&quot;</span></span>)&#x000A;)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:members</span>].insert([&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>, band_id: ... },&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Martin</span><span class="delimiter">&quot;</span></span>, band_id: ... }&#x000A;])</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.build</code><br/>
          <code>Model#{name}.new</code>
          <p class='doc'>
            <i>
              Build a new document in the relation with the provided
              attributes. Does not save the new document.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.members.build(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)&#x000A;band.members.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.create</code><br/>
          <code>Model#{name}.create!</code>
          <p class='doc'>
            <i>
              Create a new document in the relation with the provided
              attributes and saves. With the bang version an error will
              be raised if validation fails.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.members.create(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)&#x000A;band.members.create!(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:members</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>, band_id: ... }&#x000A;)</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.clear</code><br/>
          <code>Model#{name}.delete_all</code>
          <p class='doc'>
            <i>
              Deletes all documents from the relation, without
              running any callbacks.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.members.clear&#x000A;band.members.delete_all&#x000A;band.members.delete_all(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)&#x000A;band.members.&#x000A;  where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>).delete_all</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:members</span>].find(band_id: ...).remove_all&#x000A;&#x000A;collections[<span class="symbol">:members</span>].&#x000A;  find(band_id: ..., name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>).remove_all</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.destroy_all</code>
          <p class='doc'>
            <i>
              Deletes all documents from the relation, while
              running the destroy callbacks.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.members.destroy_all&#x000A;band.members.destroy_all(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)&#x000A;band.members.&#x000A;  where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>).destroy_all</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:members</span>].find(band_id: ...).remove_all&#x000A;&#x000A;collections[<span class="symbol">:members</span>].&#x000A;  find(band_id: ..., name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>).remove_all</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.delete</code>
          <p class='doc'>
            <i>
              Deletes the matching document from the relation.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.members.delete(member)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:members</span>].&#x000A;  find(band_id: ..., name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>).remove</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.find</code>
          <p class='doc'>
            <i>
              Return documents in the relation with matching ids. Will
              raise an error if all the ids are not found by default.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.members.find(id)&#x000A;&#x000A;band.members.find(id_one, id_two)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:members</span>].find({&#x000A;  band_id: ..., _id: id&#x000A;})&#x000A;&#x000A;collections[<span class="symbol">:members</span>].find({&#x000A;  band_id: ..., _id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; [ id_one, id_two ] }&#x000A;})</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.find_or_create_by</code>
          <p class='doc'>
            <i>
              Search for the document in the relation, and if not found
              create a newly persisted one.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.members.&#x000A;  find_or_create_by(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:members</span>].find({&#x000A;  band_id: ..., name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>&#x000A;})&#x000A;collections[<span class="symbol">:members</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>, band_id: ... }&#x000A;)</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.find_or_initialize_by</code>
          <p class='doc'>
            <i>
              Search for the document in the relation, and if not found
              add a new one.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.members.&#x000A;  find_or_initialize_by(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:members</span>].find({&#x000A;  band_id: ..., name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>&#x000A;})</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.where</code>
          <p class='doc'>
            <i>
              Find matching documents in the relation. This can be any
              criteria method, not just where.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.members.where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:members</span>].find({&#x000A;  band_id: ..., name: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fletch</span><span class="delimiter">&quot;</span></span>&#x000A;})</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.exists?</code>
          <p class='doc'>
            <i>
              Returns whether or not the relation has any documents.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.members.exists?</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:members</span>].find(band_id: ...).count&#x000A;</pre></div>
          </div>
        </td>
      </tr>
    </tbody>
  </table>
</section>
<section id='has_and_belongs_to_many'>
  <h2>Referenced n-n</h2>
  <p>
    Many to many relationships where the inverse documents are stored in a
    separate collection from the base document are defined using
    Mongoid's <code>has_and_belongs_to_many</code> macro. This
    exhibits similar behavior to Active Record with the exception that
    no join collection is needed, the foreign key ids are stored as
    arrays on either side of the relation.
  </p>
  <h3>Defining</h3>
  <p>
    Both sides of the relation use the same macro.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  has_and_belongs_to_many <span class="symbol">:tags</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Tag</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  field <span class="symbol">:name</span>, type: <span class="constant">String</span>&#x000A;  has_and_belongs_to_many <span class="symbol">:bands</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
  </div>
  <p>
    You can create a one sided many to many if you want to mimic a has_many
    that stores the keys as an array on the parent.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="keyword">class</span> <span class="class">Band</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  has_and_belongs_to_many <span class="symbol">:tags</span>, inverse_of: <span class="predefined-constant">nil</span>&#x000A;<span class="keyword">end</span>&#x000A;&#x000A;<span class="keyword">class</span> <span class="class">Tag</span>&#x000A;  include <span class="constant">Mongoid</span>::<span class="constant">Document</span>&#x000A;  field <span class="symbol">:name</span>, type: <span class="constant">String</span>&#x000A;<span class="keyword">end</span>&#x000A;</pre></div>
  </div>
  <h3>Storage</h3>
  <p>
    When defining a relation of this nature, each document is stored in its
    respective collection, and each document contains a "foreign key"
    reference to the other in the form of an array.
  </p>
  <div class="CodeRay">
    <div class="code"><pre><span class="comment"># The band document.</span>&#x000A;{&#x000A;  <span class="string"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e9</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="string"><span class="delimiter">&quot;</span><span class="content">tag_ids</span><span class="delimiter">&quot;</span></span> : [ ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7f2</span><span class="delimiter">&quot;</span></span>) ]&#x000A;}&#x000A;&#x000A;<span class="comment"># The tag document.</span>&#x000A;{&#x000A;  <span class="string"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> : ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7f2</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="string"><span class="delimiter">&quot;</span><span class="content">band_ids</span><span class="delimiter">&quot;</span></span> : [ ObjectId(<span class="string"><span class="delimiter">&quot;</span><span class="content">4d3ed089fb60ab534684b7e9</span><span class="delimiter">&quot;</span></span>) ]&#x000A;}&#x000A;</pre></div>
  </div>
  <h3>Operations</h3>
  <p>
    Once the relation is defined, the following operations are available, and
    the following table shows any database operations that are performed if
    applicable. The previously defined models will be used for example code.
  </p>
  <div class='well'>
    <table>
      <tr>
        <td class='achtung'><img src="../../../images/achtung.png" /></td>
        <td class='note'>
          <p>
            Many to many relations require usually double the amount of
            hits to the database to keep both sides of the relation in
            sync, since keys are stored on both sides. Due to this they
            are slower and should be used with caution.
          </p>
        </td>
      </tr>
    </table>
  </div>
  <table class='table table-bordered table-striped'>
    <thead>
      <tr>
        <th>Operation</th>
        <th>Mongoid</th>
        <th>Moped</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class='doc'>
          <code>Model#{name}</code>
          <p class='doc'>
            <i>Get the related documents.</i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.tags</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}=</code>
          <p class='doc'>
            <i>
              Set the related documents. If the parent document is persisted,
              then the child will be saved immediately along with the parent to
              keep the keys consistent. If setting to <code>nil</code> or
              <code>[]</code> then the children will be deleted.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.tags = [ <span class="constant">Tag</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>) ]&#x000A;&#x000A;band.tags = <span class="predefined-constant">nil</span>&#x000A;band.tags = []</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:tags</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>, band_ids: ... }&#x000A;)&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$push</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })&#x000A;&#x000A;collections[<span class="symbol">:tags</span>].find(...).remove&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$pull</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.<<</code><br/>
          <code>Model#{name}.push</code>
          <p class='doc'>
            <i>
              Push a new document onto the relation. If the parent is
              persisted, then the child documents will be automatically
              saved.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.tags &lt;&lt; <span class="constant">Tag</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)&#x000A;band.tags.push(<span class="constant">Tag</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>))</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:tags</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>, band_ids: ... }&#x000A;)&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$push</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.concat</code>
          <p class='doc'>
            <i>
              Push multiple documents onto the relation. If the parent is
              persisted, then the child documents will be automatically
              saved in a single batch.
              <b>Note that while batch operations limit the number
              of database calls to a single one for the new documents, it
              is in fact at least 2x slower from the Ruby side. This is due
              to the fact that 2 iterations over all documents must occur
              to ensure that all the before callbacks run before the db hit,
              and that all after callbacks have to wait until after.</b>
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.tags.concat(&#x000A;  <span class="constant">Tag</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>),&#x000A;  <span class="constant">Tag</span>.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">new wave</span><span class="delimiter">&quot;</span></span>)&#x000A;)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:tags</span>].insert([&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>, band_ids: ... },&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">new wave</span><span class="delimiter">&quot;</span></span>, band_ids: ... }&#x000A;])&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$pushAll</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.build</code><br/>
          <code>Model#{name}.new</code>
          <p class='doc'>
            <i>
              Build a new document in the relation with the provided
              attributes. Does not save the new document.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.tags.build(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)&#x000A;band.tags.new(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td></td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.create</code><br/>
          <code>Model#{name}.create!</code>
          <p class='doc'>
            <i>
              Create a new document in the relation with the provided
              attributes and saves. With the bang version an error will
              be raised if validation fails.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.tags.create(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)&#x000A;band.tags.create!(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:tags</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>, band_ids: ... }&#x000A;)&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$push</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.clear</code><br/>
          <code>Model#{name}.delete_all</code>
          <p class='doc'>
            <i>
              Deletes all documents from the relation, without
              running any callbacks.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.tags.clear&#x000A;band.tags.delete_all&#x000A;band.tags.delete_all(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)&#x000A;band.tags.&#x000A;  where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>).delete_all</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:tags</span>].find(_id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }).remove_all&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$pullAll</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })&#x000A;&#x000A;collections[<span class="symbol">:tags</span>].&#x000A;  find(_id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }, name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>).remove_all&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$pullAll</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.destroy_all</code>
          <p class='doc'>
            <i>
              Deletes all documents from the relation, while
              running the destroy callbacks.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.tags.destroy_all&#x000A;band.tags.destroy_all(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)&#x000A;band.tags.&#x000A;  where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>).destroy_all</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:tags</span>].find(_id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }).remove_all&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$pullAll</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })&#x000A;&#x000A;collections[<span class="symbol">:tags</span>].&#x000A;  find(_id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }, name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>).remove_all&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$pullAll</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.delete</code>
          <p class='doc'>
            <i>
              Deletes the matching document from the relation.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.tags.delete(tag)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:tags</span>].&#x000A;  find(_id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }, name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>).remove&#x000A;collections[<span class="symbol">:bands</span>].find(...).&#x000A;  update(<span class="string"><span class="delimiter">&quot;</span><span class="content">$pull</span><span class="delimiter">&quot;</span></span> =&gt; { tag_ids: ... })</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.find</code>
          <p class='doc'>
            <i>
              Return documents in the relation with matching ids. Will
              raise an error if all the ids are not found by default.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.tags.find(id)&#x000A;&#x000A;band.tags.find(id_one, id_two)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:tags</span>].find({&#x000A;  _id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }, { <span class="string"><span class="delimiter">&quot;</span><span class="content">$and</span><span class="delimiter">&quot;</span></span> =&gt; [{ _id: id }] }&#x000A;})&#x000A;&#x000A;collections[<span class="symbol">:tags</span>].find({&#x000A;  _id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... },&#x000A;  { <span class="string"><span class="delimiter">&quot;</span><span class="content">$and</span><span class="delimiter">&quot;</span></span> =&gt; [{ _id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; [ id_one, id_two ]}}] }&#x000A;})</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.find_or_create_by</code>
          <p class='doc'>
            <i>
              Search for the document in the relation, and if not found
              create a newly persisted one.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.tags.&#x000A;  find_or_create_by(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:tags</span>].find({&#x000A;  _id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }, name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>&#x000A;})&#x000A;collections[<span class="symbol">:tags</span>].insert(&#x000A;  { name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>, band_ids: ... }&#x000A;)</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.find_or_initialize_by</code>
          <p class='doc'>
            <i>
              Search for the document in the relation, and if not found
              add a new one.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.tags.&#x000A;  find_or_initialize_by(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:tags</span>].find({&#x000A;  _id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }, name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>&#x000A;})</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.where</code>
          <p class='doc'>
            <i>
              Find matching documents in the relation. This can be any
              criteria method, not just where.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.tags.where(name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>)</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:tags</span>].find({&#x000A;  _id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }, name: <span class="string"><span class="delimiter">&quot;</span><span class="content">electro</span><span class="delimiter">&quot;</span></span>&#x000A;})</pre></div>
          </div>
        </td>
      </tr>
      <tr>
        <td class='doc'>
          <code>Model#{name}.exists?</code>
          <p class='doc'>
            <i>
              Returns whether or not the relation has any documents.
            </i>
          </p>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>band.tags.exists?</pre></div>
          </div>
        </td>
        <td>
          <div class="CodeRay">
            <div class="code"><pre>collections[<span class="symbol">:tags</span>].&#x000A;  find(_id: { <span class="string"><span class="delimiter">&quot;</span><span class="content">$in</span><span class="delimiter">&quot;</span></span> =&gt; ... }).count</pre></div>
          </div>
        </td>
      </tr>
    </tbody>
  </table>
</section>
      </div>
    </div>
  </body>
</html>
