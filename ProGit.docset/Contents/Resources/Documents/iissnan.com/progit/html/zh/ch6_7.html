<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>子树合并 - Git 工具 - Pro Git 简体中文版</title><link rel="stylesheet" type="text/css" href="../../assets/vendor/bootstrap/dist/css/bootstrap.min.css"><link rel="stylesheet" type="text/css" href="../../assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" type="text/css" href="../../assets/vendor/nprogress/nprogress.css"><link rel="stylesheet" type="text/css" href="../../assets/css/main.css"><link rel="shortcut icon" type="images/x-icon" href="../../assets/img/favicon.ico"></head><body><a href="ch6_7.html#main" class="sr-only">SKIP TO CONTENT</a><div id="pjax-container"><div id="header" class="navbar navbar-fixed-top navbar-inverse"><div class="container"><div class="navbar-header"><a id="brand" href="http://iissnan.com/progit/"><img src="../../assets/img/git-logo.png" alt="git" class="logo"></a><button type="button" data-toggle="collapse" data-target=".navigation" class="navbar-toggle"><span class="sr-only">Toggle Navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button></div><div class="navbar-collapse collapse navigation"><ul class="nav navbar-nav"><li class="dropdown"><a data-toggle="dropdown" href="ch6_7.html#" class="dropdown-toggle"><span class="octicon octicon-list-unordered"></span> 目录<b class="caret"></b></a><ul role="menu" class="dropdown-menu menu-toc"><li class="menu-toc-chapter"><a href="ch1_0.html">1   起步 </a><ul class="menu-section-links"><li><a href="ch1_1.html">1.1   关于版本控制 </a></li><li><a href="ch1_2.html">1.2   Git 简史 </a></li><li><a href="ch1_3.html">1.3   Git 基础 </a></li><li><a href="ch1_4.html">1.4   安装 Git </a></li><li><a href="ch1_5.html">1.5   初次运行 Git 前的配置 </a></li><li><a href="ch1_6.html">1.6   获取帮助 </a></li><li><a href="ch1_7.html">1.7   小结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch2_0.html">2   Git 基础 </a><ul class="menu-section-links"><li><a href="ch2_1.html">2.1   取得项目的 Git 仓库 </a></li><li><a href="ch2_2.html">2.2   记录每次更新到仓库 </a></li><li><a href="ch2_3.html">2.3   查看提交历史 </a></li><li><a href="ch2_4.html">2.4   撤消操作 </a></li><li><a href="ch2_5.html">2.5   远程仓库的使用 </a></li><li><a href="ch2_6.html">2.6   打标签 </a></li><li><a href="ch2_7.html">2.7   技巧和窍门 </a></li><li><a href="ch2_8.html">2.8   小结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch3_0.html">3   Git 分支 </a><ul class="menu-section-links"><li><a href="ch3_1.html">3.1   何谓分支 </a></li><li><a href="ch3_2.html">3.2   分支的新建与合并 </a></li><li><a href="ch3_3.html">3.3   分支的管理 </a></li><li><a href="ch3_4.html">3.4   利用分支进行开发的工作流程 </a></li><li><a href="ch3_5.html">3.5   远程分支 </a></li><li><a href="ch3_6.html">3.6   分支的衍合 </a></li><li><a href="ch3_7.html">3.7   小结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch4_0.html">4   服务器上的 Git </a><ul class="menu-section-links"><li><a href="ch4_1.html">4.1   协议 </a></li><li><a href="ch4_2.html">4.2   在服务器上部署 Git </a></li><li><a href="ch4_3.html">4.3   生成 SSH 公钥 </a></li><li><a href="ch4_4.html">4.4   架设服务器 </a></li><li><a href="ch4_5.html">4.5   公共访问 </a></li><li><a href="ch4_6.html">4.6   GitWeb </a></li><li><a href="ch4_7.html">4.7   Gitosis </a></li><li><a href="ch4_8.html">4.8   Gitolite </a></li><li><a href="ch4_9.html">4.9   Git 守护进程 </a></li><li><a href="ch4_10.html">4.10   Git 托管服务 </a></li><li><a href="ch4_11.html">4.11   小结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch5_0.html">5   分布式 Git </a><ul class="menu-section-links"><li><a href="ch5_1.html">5.1   分布式工作流程 </a></li><li><a href="ch5_2.html">5.2   为项目作贡献 </a></li><li><a href="ch5_3.html">5.3   项目的管理 </a></li><li><a href="ch5_4.html">5.4   小结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch6_0.html">6   Git 工具 </a><ul class="menu-section-links"><li><a href="ch6_1.html">6.1   修订版本（Revision）选择 </a></li><li><a href="ch6_2.html">6.2   交互式暂存 </a></li><li><a href="ch6_3.html">6.3   储藏（Stashing） </a></li><li><a href="ch6_4.html">6.4   重写历史 </a></li><li><a href="ch6_5.html">6.5   使用 Git 调试 </a></li><li><a href="ch6_6.html">6.6   子模块 </a></li><li><a href="ch6_7.html">6.7   子树合并 </a></li><li><a href="ch6_8.html">6.8   总结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch7_0.html">7   自定义 Git </a><ul class="menu-section-links"><li><a href="ch7_1.html">7.1   配置 Git </a></li><li><a href="ch7_2.html">7.2   Git属性 </a></li><li><a href="ch7_3.html">7.3   Git挂钩 </a></li><li><a href="ch7_4.html">7.4   Git 强制策略实例 #</a></li><li><a href="ch7_5.html">7.5   总结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch8_0.html">8   Git 与其他系统 </a><ul class="menu-section-links"><li><a href="ch8_1.html">8.1   Git 与 Subversion </a></li><li><a href="ch8_2.html">8.2   迁移到 Git </a></li><li><a href="ch8_3.html">8.3   总结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch9_0.html">9   Git 内部原理 </a><ul class="menu-section-links"><li><a href="ch9_1.html">9.1   底层命令 (Plumbing) 和高层命令 (Porcelain) </a></li><li><a href="ch9_2.html">9.2   Git 对象 </a></li><li><a href="ch9_3.html">9.3   Git References </a></li><li><a href="ch9_4.html">9.4   Packfiles </a></li><li><a href="ch9_5.html">9.5   The Refspec </a></li><li><a href="ch9_6.html">9.6   传输协议 </a></li><li><a href="ch9_7.html">9.7   维护及数据恢复 </a></li><li><a href="ch9_8.html">9.8   总结 </a></li></ul></li></ul></li></ul><ul class="nav navbar-nav navbar-right"><li class="dropdown"><a data-toggle="dropdown" href="ch6_7.html#" class="dropdown-toggle"><span class="octicon octicon-globe"></span> 其他语言<b class="caret"></b></a><ul role="menu" class="dropdown-menu"><li><a href="http://iissnan.com/progit/index.en.html">English</a></li><li><a href="http://iissnan.com/progit/index.html">简体中文</a></li><li><a href="http://iissnan.com/progit/index.zh-tw.html">正體中文</a></li></ul></li><li><a href="http://iissnan.com/progit/about.html"><span class="octicon octicon-question"></span> 关于</a></li></ul></div></div></div><div id="main" class="container"><div class="row wrap"><div class="col-md-12"><div class="ph20"><h2>子树合并</h2>

<p>现在你已经看到了子模块系统的麻烦之处，让我们来看一下解决相同问题的另一途径。当 Git 归并时，它会检查需要归并的内容然后选择一个合适的归并策略。如果你归并的分支是两个，Git使用一个<em>递归</em>策略。如果你归并的分支超过两个，Git采用<em>章鱼</em>策略。这些策略是自动选择的，因为递归策略可以处理复杂的三路归并情况——比如多于一个共同祖先的——但是它只能处理两个分支的归并。章鱼归并可以处理多个分支但是但必须更加小心以避免冲突带来的麻烦，因此它被选中作为归并两个以上分支的默认策略。</p>

<p>实际上，你也可以选择其他策略。其中的一个就是<em>子树</em>归并，你可以用它来处理子项目问题。这里你会看到如何换用子树归并的方法来实现前一节里所做的 rack 的嵌入。</p>

<p>子树归并的思想是你拥有两个工程，其中一个项目映射到另外一个项目的子目录中，反过来也一样。当你指定一个子树归并，Git可以聪明地探知其中一个是另外一个的子树从而实现正确的归并——这相当神奇。</p>

<p>首先你将 Rack 应用加入到项目中。你将 Rack 项目当作你项目中的一个远程引用，然后将它检出到它自身的分支：</p>

<pre><code>$ git remote add rack_remote git@github.com:schacon/rack.git
$ git fetch rack_remote
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From git@github.com:schacon/rack
 * [new branch]      build      -&gt; rack_remote/build
 * [new branch]      master     -&gt; rack_remote/master
 * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4
 * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch &quot;rack_branch&quot;</code></pre>

<p>现在在你的<code>rack_branch</code>分支中就有了Rack项目的根目录，而你自己的项目在<code>master</code>分支中。如果你先检出其中一个然后另外一个，你会看到它们有不同的项目根目录：</p>

<pre><code>$ ls
AUTHORS	       KNOWN-ISSUES   Rakefile      contrib	       lib
COPYING	       README         bin           example	       test
$ git checkout master
Switched to branch &quot;master&quot;
$ ls
README</code></pre>

<p>要将 Rack 项目当作子目录拉取到你的<code>master</code>项目中。你可以在 Git 中用<code>git read-tree</code>来实现。你会在第9章学到更多与<code>read-tree</code>和它的朋友相关的东西，当前你会知道它读取一个分支的根目录树到当前的暂存区和工作目录。你只要切换回你的<code>master</code>分支，然后拉取<code>rack_branch</code>到你主项目的<code>master</code>分支的<code>rack</code>子目录：</p>

<pre><code>$ git read-tree --prefix=rack/ -u rack_branch</code></pre>

<p>当你提交的时候，看起来就像你在那个子目录下拥有Rack的文件——就像你从一个tarball里拷贝的一样。有意思的是你可以比较容易地归并其中一个分支的变更到另外一个。因此，如果 Rack 项目更新了，你可以通过切换到那个分支并执行拉取来获得上游的变更：</p>

<pre><code>$ git checkout rack_branch
$ git pull</code></pre>

<p>然后，你可以将那些变更归并回你的 master 分支。你可以使用<code>git merge -s subtree</code>，它会工作的很好；但是 Git 同时会把历史归并到一起，这可能不是你想要的。为了拉取变更并预置提交说明，需要在<code>-s subtree</code>策略选项的同时使用<code>--squash</code>和<code>--no-commit</code>选项。</p>

<pre><code>$ git checkout master
$ git merge --squash -s subtree --no-commit rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested</code></pre>

<p>所有 Rack 项目的变更都被归并并且可以进行本地提交。你也可以做相反的事情——在你主分支的<code>rack</code>目录里进行变更然后归并回<code>rack_branch</code>分支，然后将它们提交给维护者或者推送到上游。</p>

<p>为了得到<code>rack</code>子目录和你<code>rack_branch</code>分支的区别——以决定你是否需要归并它们——你不能使用一般的<code>diff</code>命令。而是对你想比较的分支运行<code>git diff-tree</code>：</p>

<pre><code>$ git diff-tree -p rack_branch</code></pre>

<p>或者，为了比较你的<code>rack</code>子目录和服务器上你拉取时的<code>master</code>分支，你可以运行</p>

<pre><code>$ git diff-tree -p rack_remote/master</code></pre>

</div></div></div><div class="footer"><div class="pull-left"><span class="build-date">构建时间：2015-01-17 00:32:21</span>，<span class="build-source-version">基于书籍源码版本：<a href="https://github.com/progit/progit/tree/6895c8264604032f24ffdee44123b922aabadf5b" target="_blank">6895c82</a></span>，<span class="application-version">程序版本：0.0.7</span>。</div><div class="pull-right">制作者<a href="http://iissnan.com" target="_blank"> iissnan</a></div></div></div></div><script src="../../assets/vendor/jquery/dist/jquery.min.js"></script><script src="../../assets/vendor/jquery-pjax/jquery.pjax.js"></script><script src="../../assets/vendor/nprogress/nprogress.js"></script><script src="../../assets/vendor/bootstrap/dist/js/bootstrap.min.js"></script><script src="../../assets/js/main.js"></script></body></html>