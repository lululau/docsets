<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>记录每次更新到仓库 - Git 基础 - Pro Git 简体中文版</title><link rel="stylesheet" type="text/css" href="../../assets/vendor/bootstrap/dist/css/bootstrap.min.css"><link rel="stylesheet" type="text/css" href="../../assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" type="text/css" href="../../assets/vendor/nprogress/nprogress.css"><link rel="stylesheet" type="text/css" href="../../assets/css/main.css"><link rel="shortcut icon" type="images/x-icon" href="../../assets/img/favicon.ico"></head><body><a href="ch2_2.html#main" class="sr-only">SKIP TO CONTENT</a><div id="pjax-container"><div id="header" class="navbar navbar-fixed-top navbar-inverse"><div class="container"><div class="navbar-header"><a id="brand" href="http://iissnan.com/progit/"><img src="../../assets/img/git-logo.png" alt="git" class="logo"></a><button type="button" data-toggle="collapse" data-target=".navigation" class="navbar-toggle"><span class="sr-only">Toggle Navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button></div><div class="navbar-collapse collapse navigation"><ul class="nav navbar-nav"><li class="dropdown"><a data-toggle="dropdown" href="ch2_2.html#" class="dropdown-toggle"><span class="octicon octicon-list-unordered"></span> 目录<b class="caret"></b></a><ul role="menu" class="dropdown-menu menu-toc"><li class="menu-toc-chapter"><a href="ch1_0.html">1   起步 </a><ul class="menu-section-links"><li><a href="ch1_1.html">1.1   关于版本控制 </a></li><li><a href="ch1_2.html">1.2   Git 简史 </a></li><li><a href="ch1_3.html">1.3   Git 基础 </a></li><li><a href="ch1_4.html">1.4   安装 Git </a></li><li><a href="ch1_5.html">1.5   初次运行 Git 前的配置 </a></li><li><a href="ch1_6.html">1.6   获取帮助 </a></li><li><a href="ch1_7.html">1.7   小结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch2_0.html">2   Git 基础 </a><ul class="menu-section-links"><li><a href="ch2_1.html">2.1   取得项目的 Git 仓库 </a></li><li><a href="ch2_2.html">2.2   记录每次更新到仓库 </a></li><li><a href="ch2_3.html">2.3   查看提交历史 </a></li><li><a href="ch2_4.html">2.4   撤消操作 </a></li><li><a href="ch2_5.html">2.5   远程仓库的使用 </a></li><li><a href="ch2_6.html">2.6   打标签 </a></li><li><a href="ch2_7.html">2.7   技巧和窍门 </a></li><li><a href="ch2_8.html">2.8   小结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch3_0.html">3   Git 分支 </a><ul class="menu-section-links"><li><a href="ch3_1.html">3.1   何谓分支 </a></li><li><a href="ch3_2.html">3.2   分支的新建与合并 </a></li><li><a href="ch3_3.html">3.3   分支的管理 </a></li><li><a href="ch3_4.html">3.4   利用分支进行开发的工作流程 </a></li><li><a href="ch3_5.html">3.5   远程分支 </a></li><li><a href="ch3_6.html">3.6   分支的衍合 </a></li><li><a href="ch3_7.html">3.7   小结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch4_0.html">4   服务器上的 Git </a><ul class="menu-section-links"><li><a href="ch4_1.html">4.1   协议 </a></li><li><a href="ch4_2.html">4.2   在服务器上部署 Git </a></li><li><a href="ch4_3.html">4.3   生成 SSH 公钥 </a></li><li><a href="ch4_4.html">4.4   架设服务器 </a></li><li><a href="ch4_5.html">4.5   公共访问 </a></li><li><a href="ch4_6.html">4.6   GitWeb </a></li><li><a href="ch4_7.html">4.7   Gitosis </a></li><li><a href="ch4_8.html">4.8   Gitolite </a></li><li><a href="ch4_9.html">4.9   Git 守护进程 </a></li><li><a href="ch4_10.html">4.10   Git 托管服务 </a></li><li><a href="ch4_11.html">4.11   小结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch5_0.html">5   分布式 Git </a><ul class="menu-section-links"><li><a href="ch5_1.html">5.1   分布式工作流程 </a></li><li><a href="ch5_2.html">5.2   为项目作贡献 </a></li><li><a href="ch5_3.html">5.3   项目的管理 </a></li><li><a href="ch5_4.html">5.4   小结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch6_0.html">6   Git 工具 </a><ul class="menu-section-links"><li><a href="ch6_1.html">6.1   修订版本（Revision）选择 </a></li><li><a href="ch6_2.html">6.2   交互式暂存 </a></li><li><a href="ch6_3.html">6.3   储藏（Stashing） </a></li><li><a href="ch6_4.html">6.4   重写历史 </a></li><li><a href="ch6_5.html">6.5   使用 Git 调试 </a></li><li><a href="ch6_6.html">6.6   子模块 </a></li><li><a href="ch6_7.html">6.7   子树合并 </a></li><li><a href="ch6_8.html">6.8   总结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch7_0.html">7   自定义 Git </a><ul class="menu-section-links"><li><a href="ch7_1.html">7.1   配置 Git </a></li><li><a href="ch7_2.html">7.2   Git属性 </a></li><li><a href="ch7_3.html">7.3   Git挂钩 </a></li><li><a href="ch7_4.html">7.4   Git 强制策略实例 #</a></li><li><a href="ch7_5.html">7.5   总结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch8_0.html">8   Git 与其他系统 </a><ul class="menu-section-links"><li><a href="ch8_1.html">8.1   Git 与 Subversion </a></li><li><a href="ch8_2.html">8.2   迁移到 Git </a></li><li><a href="ch8_3.html">8.3   总结 </a></li></ul></li><li class="menu-toc-chapter"><a href="ch9_0.html">9   Git 内部原理 </a><ul class="menu-section-links"><li><a href="ch9_1.html">9.1   底层命令 (Plumbing) 和高层命令 (Porcelain) </a></li><li><a href="ch9_2.html">9.2   Git 对象 </a></li><li><a href="ch9_3.html">9.3   Git References </a></li><li><a href="ch9_4.html">9.4   Packfiles </a></li><li><a href="ch9_5.html">9.5   The Refspec </a></li><li><a href="ch9_6.html">9.6   传输协议 </a></li><li><a href="ch9_7.html">9.7   维护及数据恢复 </a></li><li><a href="ch9_8.html">9.8   总结 </a></li></ul></li></ul></li></ul><ul class="nav navbar-nav navbar-right"><li class="dropdown"><a data-toggle="dropdown" href="ch2_2.html#" class="dropdown-toggle"><span class="octicon octicon-globe"></span> 其他语言<b class="caret"></b></a><ul role="menu" class="dropdown-menu"><li><a href="http://iissnan.com/progit/index.en.html">English</a></li><li><a href="http://iissnan.com/progit/index.html">简体中文</a></li><li><a href="http://iissnan.com/progit/index.zh-tw.html">正體中文</a></li></ul></li><li><a href="http://iissnan.com/progit/about.html"><span class="octicon octicon-question"></span> 关于</a></li></ul></div></div></div><div id="main" class="container"><div class="row wrap"><div class="col-md-12"><div class="ph20"><h2>记录每次更新到仓库</h2>

<p>现在我们手上已经有了一个真实项目的 Git 仓库，并从这个仓库中取出了所有文件的工作拷贝。接下来，对这些文件作些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。</p>

<p>请记住，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p>

<p>在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。所以使用 Git 时的文件状态变化周期如图 2-1 所示。</p>

<p><img class="img-responsive center-block" src="../../book_src/figures/18333fig0201-tn.png"></br>
图 2-1. 文件的状态变化周期</p>

<h3>检查当前文件状态</h3>

<p>要确定哪些文件当前处于什么状态，可以用 <code>git status</code> 命令。如果在克隆仓库之后立即执行此命令，会看到类似这样的输出：</p>

<pre><code>$ git status
On branch master
nothing to commit, working directory clean</code></pre>

<p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪的新文件，否则 Git 会在这里列出来。最后，该命令还显示了当前所在的分支是 <code>master</code>，这是默认的分支名称，实际是可以修改的，现在先不用考虑。下一章我们就会详细讨论分支和引用。</p>

<p>现在让我们用 vim 创建一个新文件 README，保存退出后运行 <code>git status</code> 会看到该文件出现在未跟踪文件列表中：</p>

<pre><code>$ vim README
$ git status
On branch master
Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

        README

nothing added to commit but untracked files present (use &quot;git add&quot; to track)</code></pre>

<p>在状态报告中可以看到新建的<code>README</code>文件出现在“Untracked files”下面。未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，因而不用担心把临时文件什么的也归入版本管理。不过现在的例子中，我们确实想要跟踪管理 README 这个文件。</p>

<h3>跟踪新文件</h3>

<p>使用命令 <code>git add</code> 开始跟踪一个新文件。所以，要跟踪 README 文件，运行：</p>

<pre><code>$ git add README</code></pre>

<p>此时再运行 <code>git status</code> 命令，会看到 README 文件已被跟踪，并处于暂存状态：</p>

<pre><code>$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

        new file:   README</code></pre>

<p>只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。你可能会想起之前我们使用 <code>git init</code> 后就运行了 <code>git add</code> 命令，开始跟踪当前目录下的文件。在 <code>git add</code> 后面可以指明要跟踪的文件或目录路径。如果是目录的话，就说明要递归跟踪该目录下的所有文件。（译注：其实 <code>git add</code> 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了。）</p>

<h3>暂存已修改文件</h3>

<p>现在我们修改下之前已跟踪过的文件 <code>benchmarks.rb</code>，然后再次运行 <code>status</code> 命令，会看到这样的状态报告：</p>

<pre><code>$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

        new file:   README

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

        modified:   benchmarks.rb</code></pre>

<p>文件 <code>benchmarks.rb</code> 出现在 “Changes not staged for commit” 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行 <code>git add</code> 命令（这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）。现在让我们运行 <code>git add</code> 将 benchmarks.rb 放到暂存区，然后再看看 <code>git status</code> 的输出：</p>

<pre><code>$ git add benchmarks.rb
$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

        new file:   README
        modified:   benchmarks.rb</code></pre>

<p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。假设此时，你想要在 <code>benchmarks.rb</code> 里再加条注释，重新编辑存盘后，准备好提交。不过且慢，再运行 <code>git status</code> 看看：</p>

<pre><code>$ vim benchmarks.rb
$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

        new file:   README
        modified:   benchmarks.rb

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

        modified:   benchmarks.rb</code></pre>

<p>怎么回事？ <code>benchmarks.rb</code> 文件出现了两次！一次算未暂存，一次算已暂存，这怎么可能呢？好吧，实际上 Git 只不过暂存了你运行 <code>git add</code> 命令时的版本，如果现在提交，那么提交的是添加注释前的版本，而非当前工作目录中的版本。所以，运行了 <code>git add</code> 之后又作了修订的文件，需要重新运行 <code>git add</code> 把最新版本重新暂存起来：</p>

<pre><code>$ git add benchmarks.rb
$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

        new file:   README
        modified:   benchmarks.rb</code></pre>

<h3>忽略某些文件</h3>

<p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。来看一个实际的例子：</p>

<pre><code>$ cat .gitignore
*.[oa]
*~</code></pre>

<p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。第二行告诉 Git 忽略所有以波浪符（<code>~</code>）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略 <code>log</code>，<code>tmp</code> 或者 <code>pid</code> 目录，以及自动生成的文档等等。要养成一开始就设置好 <code>.gitignore</code> 文件的习惯，以免将来误提交这类无用的文件。</p>

<p>文件 <code>.gitignore</code> 的格式规范如下：</p>

<ul><li>所有空行或者以注释符号 <code>＃</code> 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式最后跟反斜杠（<code>/</code>）说明要忽略的是目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li></ul>

<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。</p>

<p>我们再看一个 <code>.gitignore</code> 文件的例子：</p>

<pre><code># 此为注释 – 将被 Git 忽略
# 忽略所有 .a 结尾的文件
*.a
# 但 lib.a 除外
!lib.a
# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
/TODO
# 忽略 build/ 目录下的所有文件
build/
# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
doc/*.txt
# ignore all .txt files in the doc/ directory
doc/**/*.txt</code></pre>

<p>A <code>**/</code> pattern is available in Git since version 1.8.2.</p>

<h3>查看已暂存和未暂存的更新</h3>

<p>实际上 <code>git status</code> 的显示比较简单，仅仅是列出了修改过的文件，如果要查看具体修改了什么地方，可以用 <code>git diff</code> 命令。稍后我们会详细介绍 <code>git diff</code>，不过现在，它已经能回答我们的两个问题了：当前做的哪些更新还没有暂存？有哪些更新已经暂存起来准备好了下次提交？ <code>git diff</code> 会使用文件补丁的格式显示具体添加和删除的行。</p>

<p>假如再次修改 <code>README</code> 文件后暂存，然后编辑 <code>benchmarks.rb</code> 文件后先别暂存，运行 <code>status</code> 命令将会看到：</p>

<pre><code>$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

        new file:   README

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

        modified:   benchmarks.rb</code></pre>

<p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>：</p>

<pre><code>$ git diff
diff --git a/benchmarks.rb b/benchmarks.rb
index 3cb747f..da65585 100644
--- a/benchmarks.rb
+++ b/benchmarks.rb
@@ -36,6 +36,10 @@ def main
           @commit.parents[0].parents[0].parents[0]
         end

+        run_code(x, &#39;commits 1&#39;) do
+          git.commits.size
+        end
+
         run_code(x, &#39;commits 2&#39;) do
           log = git.commits(&#39;master&#39;, 15)
           log.size</code></pre>

<p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p>

<p>若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 <code>git diff --cached</code> 命令。（Git 1.6.1 及更高版本还允许使用 <code>git diff --staged</code>，效果是相同的，但更好记些。）来看看实际的效果：</p>

<pre><code>$ git diff --cached
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README2
@@ -0,0 +1,5 @@
+grit
+ by Tom Preston-Werner, Chris Wanstrath
+ http://github.com/mojombo/grit
+
+Grit is a Ruby library for extracting information from a Git repository</code></pre>

<p>请注意，单单 <code>git diff</code> 不过是显示还没有暂存起来的改动，而不是这次工作和上次提交之间的差异。所以有时候你一下子暂存了所有更新过的文件后，运行 <code>git diff</code> 后却什么也没有，就是这个原因。</p>

<p>像之前说的，暂存 benchmarks.rb 后再编辑，运行 <code>git status</code> 会看到暂存前后的两个版本：</p>

<pre><code>$ git add benchmarks.rb
$ echo &#39;# test line&#39; &gt;&gt; benchmarks.rb
$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

        modified:   benchmarks.rb

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

        modified:   benchmarks.rb</code></pre>

<p>现在运行 <code>git diff</code> 看暂存前后的变化：</p>

<pre><code>$ git diff
diff --git a/benchmarks.rb b/benchmarks.rb
index e445e28..86b2f7c 100644
--- a/benchmarks.rb
+++ b/benchmarks.rb
@@ -127,3 +127,4 @@ end
 main()

 ##pp Grit::GitRuby.cache_client.stats
+# test line</code></pre>

<p>然后用 <code>git diff --cached</code> 查看已经暂存起来的变化：</p>

<pre><code>$ git diff --cached
diff --git a/benchmarks.rb b/benchmarks.rb
index 3cb747f..e445e28 100644
--- a/benchmarks.rb
+++ b/benchmarks.rb
@@ -36,6 +36,10 @@ def main
          @commit.parents[0].parents[0].parents[0]
        end

+        run_code(x, &#39;commits 1&#39;) do
+          git.commits.size
+        end
+
        run_code(x, &#39;commits 2&#39;) do
          log = git.commits(&#39;master&#39;, 15)
          log.size</code></pre>

<h3>提交更新</h3>

<p>现在的暂存区域已经准备妥当可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有 <code>git add</code> 过，否则提交的时候不会记录这些还没暂存起来的变化。所以，每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了，然后再运行提交命令 <code>git commit</code>：</p>

<pre><code>$ git commit</code></pre>

<p>这种方式会启动文本编辑器以便输入本次提交的说明。（默认会启用 shell 的环境变量 <code>$EDITOR</code> 所指定的软件，一般都是 vim 或 emacs。当然也可以按照第一章介绍的方式，使用 <code>git config --global core.editor</code> 命令设定你喜欢的编辑软件。）</p>

<p>编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：</p>

<pre><code># Please enter the commit message for your changes. Lines starting
# with &#39;#&#39; will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#       new file:   README
#       modified:   benchmarks.rb
#
~
~
~
&quot;.git/COMMIT_EDITMSG&quot; 10L, 283C</code></pre>

<p>可以看到，默认的提交消息包含最后一次运行 <code>git status</code> 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。（如果觉得这还不够，可以用 <code>-v</code> 选项将修改差异的每一行都包含到注释中来。）退出编辑器时，Git 会丢掉注释行，将说明内容和本次更新提交到仓库。</p>

<p>另外也可以用 -m 参数后跟提交说明的方式，在一行命令中提交更新：</p>

<pre><code>$ git commit -m &quot;Story 182: Fix benchmarks for speed&quot;
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 3 insertions(+)
 create mode 100644 README</code></pre>

<p>好，现在你已经创建了第一个提交！可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（<code>463dc4f</code>），以及在本次提交中，有多少文件修订过，多少行添改和删改过。</p>

<p>记住，提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>

<h3>跳过使用暂存区域</h3>

<p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤：</p>

<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

        modified:   benchmarks.rb

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
$ git commit -a -m &#39;added new benchmarks&#39;
[master 83e38c7] added new benchmarks
 1 files changed, 5 insertions(+)</code></pre>

<p>看到了吗？提交之前不再需要 <code>git add</code> 文件 benchmarks.rb 了。</p>

<h3>移除文件</h3>

<p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>

<p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是<em>未暂存</em>清单）看到：</p>

<pre><code>$ rm grit.gemspec
$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

        deleted:    grit.gemspec

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre>

<p>然后再运行 <code>git rm</code> 记录此次移除文件的操作：</p>

<pre><code>$ git rm grit.gemspec
rm &#39;grit.gemspec&#39;
$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

        deleted:    grit.gemspec</code></pre>

<p>最后提交的时候，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>（译注：即 force 的首字母），以防误删除文件后丢失修改的内容。</p>

<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 <code>.a</code> 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 <code>.gitignore</code> 文件中补上，用 <code>--cached</code> 选项即可：</p>

<pre><code>$ git rm --cached readme.txt</code></pre>

<p>后面可以列出文件或者目录的名字，也可以使用 glob 模式。比方说：</p>

<pre><code>$ git rm log/\*.log</code></pre>

<p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>，因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开（译注：实际上不加反斜杠也可以运行，只不过按照 shell 扩展的话，仅仅删除指定目录下的文件而不会递归匹配。上面的例子本来就指定了目录，所以效果等同，但下面的例子就会用递归方式匹配，所以必须加反斜杠。）。此命令删除所有 <code>log/</code> 目录下扩展名为 <code>.log</code> 的文件。类似的比如：</p>

<pre><code>$ git rm \*~</code></pre>

<p>会递归删除当前目录及其子目录中所有 <code>~</code> 结尾的文件。</p>

<h3>移动文件</h3>

<p>不像其他的 VCS 系统，Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。</p>

<p>既然如此，当你看到 Git 的 <code>mv</code> 命令时一定会困惑不已。要在 Git 中对文件改名，可以这么做：</p>

<pre><code>$ git mv file_from file_to</code></pre>

<p>它会恰如预期般正常工作。实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p>

<pre><code>$ git mv README.txt README
$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

        renamed:    README.txt -&gt; README</code></pre>

<p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p>

<pre><code>$ mv README.txt README
$ git rm README.txt
$ git add README</code></pre>

<p>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式都一样。当然，直接用 <code>git mv</code> 轻便得多，不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p>

</div></div></div><div class="footer"><div class="pull-left"><span class="build-date">构建时间：2015-01-17 00:32:21</span>，<span class="build-source-version">基于书籍源码版本：<a href="https://github.com/progit/progit/tree/6895c8264604032f24ffdee44123b922aabadf5b" target="_blank">6895c82</a></span>，<span class="application-version">程序版本：0.0.7</span>。</div><div class="pull-right">制作者<a href="http://iissnan.com" target="_blank"> iissnan</a></div></div></div></div><script src="../../assets/vendor/jquery/dist/jquery.min.js"></script><script src="../../assets/vendor/jquery-pjax/jquery.pjax.js"></script><script src="../../assets/vendor/nprogress/nprogress.js"></script><script src="../../assets/vendor/bootstrap/dist/js/bootstrap.min.js"></script><script src="../../assets/js/main.js"></script></body></html>