<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <title>6 ETS - Elixir</title>
  <link href="http://feeds.feedburner.com/ElixirLang" rel="alternate" title="Elixir's Blog" type="application/atom+xml" />
  <link rel="stylesheet" type="text/css" href="../../css/style.css" />
  <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" id="font-bitter-css" href="../../../fonts.googleapis.com/css%3Ffamily=Bitter&amp;ver=1.css" type="text/css" media="screen" />
</head>

<body class="getting_started">
<div id="content">
  <article>
    <h1 id="6-ets">6 ETS</h1>

<div class="toc"></div>

<p>Every time we need to look up a bucket, we need to send a message to the registry. In some applications, this means the registry may become a bottleneck!</p>

<p>In this chapter we will learn about ETS (Erlang Term Storage), and how to use it as a cache mechanism. Later we will expand its usage to persist data from the supervisor to its children, allowing data to persist even on crashes.</p>

<blockquote>
<p>Warning! Don&#39;t use ETS as a cache prematurely! Log and analyze your application performance and identify which parts are bottlenecks, so you know <em>whether</em> you should cache, and <em>what</em> you should cache. This chapter is merely an example of how ETS can be used, once you&#39;ve determined the need.</p>
</blockquote>

<h2 id="6.1-ets-as-a-cache">6.1 ETS as a cache</h2>

<p>ETS allows us to store any Erlang/Elixir term in an in-memory table. Working with ETS tables is done via <a href="http://www.erlang.org/doc/man/ets.html">erlang&#39;s <code>:ets</code> module</a>:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="n">table</span> <span class="p">=</span> <span class="ss">:ets</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:buckets_registry</span><span class="p">,</span> <span class="p">[</span><span class="ss">:set</span><span class="p">,</span> <span class="ss">:protected</span><span class="p">])</span>
<span class="go">8207</span>
<span class="gp">iex&gt; </span><span class="ss">:ets</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">})</span>
<span class="go">true</span>
<span class="gp">iex&gt; </span><span class="ss">:ets</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="s2">&quot;foo&quot;</span><span class="p">)</span>
<span class="go">[{&quot;foo&quot;, #PID&lt;0.41.0&gt;}]</span>
</code></pre></div>
<p>When creating an ETS table, two arguments are required: the table name and a set of options. From the available options, we passed the table type and its access rules. We have chosen the <code>:set</code> type, which means that keys cannot be duplicated. We&#39;ve also set the table&#39;s access to <code>:protected</code>, which means that only the process that created the table can write to it, but all processes can read it from it. Those are actually the default values, so we will skip them from now on.</p>

<p>ETS tables can also be named, allowing us to access them by a given name:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="ss">:ets</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:buckets_registry</span><span class="p">,</span> <span class="p">[</span><span class="ss">:named_table</span><span class="p">])</span>
<span class="go">:buckets_registry</span>
<span class="gp">iex&gt; </span><span class="ss">:ets</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="ss">:buckets_registry</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">})</span>
<span class="go">true</span>
<span class="gp">iex&gt; </span><span class="ss">:ets</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="ss">:buckets_registry</span><span class="p">,</span> <span class="s2">&quot;foo&quot;</span><span class="p">)</span>
<span class="go">[{&quot;foo&quot;, #PID&lt;0.41.0&gt;}]</span>
</code></pre></div>
<p>Let&#39;s change the <code>KV.Registry</code> to use ETS tables. We will use the same technique as we did for the event manager and buckets supervisor, and pass the ETS table name explicitly on <code>start_link</code>. Remember that, as with server names, any local process that knows an ETS table name will be able to access that table.</p>

<p>Open up <code>lib/kv/registry.ex</code>, and let&#39;s change its implementation. We&#39;ve added comments to the source code to highlight the changes we&#39;ve made:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">KV.Registry</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="nc">GenServer</span>

  <span class="c1">## Client API</span>

  <span class="na">@doc</span> <span class="sh">&quot;&quot;&quot;</span>
<span class="sh">  Starts the registry.</span>
<span class="sh">  &quot;&quot;&quot;</span>
  <span class="kd">def</span> <span class="n">start_link</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">event_manager</span><span class="p">,</span> <span class="n">buckets</span><span class="p">,</span> <span class="n">opts</span> <span class="p">\\</span> <span class="p">[])</span> <span class="k">do</span>
    <span class="c1"># 1. We now expect the table as argument and pass it to the server</span>
    <span class="nc">GenServer</span><span class="p">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="p">{</span><span class="n">table</span><span class="p">,</span> <span class="n">event_manager</span><span class="p">,</span> <span class="n">buckets</span><span class="p">},</span> <span class="n">opts</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="na">@doc</span> <span class="sh">&quot;&quot;&quot;</span>
<span class="sh">  Looks up the bucket pid for `name` stored in `table`.</span>

<span class="sh">  Returns `{:ok, pid}` if a bucket exists, `:error` otherwise.</span>
<span class="sh">  &quot;&quot;&quot;</span>
  <span class="kd">def</span> <span class="n">lookup</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">do</span>
    <span class="c1"># 2. lookup now expects a table and looks directly into ETS.</span>
    <span class="c1">#    No request is sent to the server.</span>
    <span class="k">case</span> <span class="ss">:ets</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">do</span>
      <span class="p">[{</span><span class="o">^</span><span class="n">name</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}]</span> <span class="p">-&gt;</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span>
      <span class="p">[]</span> <span class="p">-&gt;</span> <span class="ss">:error</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="na">@doc</span> <span class="sh">&quot;&quot;&quot;</span>
<span class="sh">  Ensures there is a bucket associated with the given `name` in `server`.</span>
<span class="sh">  &quot;&quot;&quot;</span>
  <span class="kd">def</span> <span class="n">create</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">do</span>
    <span class="nc">GenServer</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="p">{</span><span class="ss">:create</span><span class="p">,</span> <span class="n">name</span><span class="p">})</span>
  <span class="k">end</span>

  <span class="c1">## Server callbacks</span>

  <span class="kd">def</span> <span class="n">init</span><span class="p">({</span><span class="n">table</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">buckets</span><span class="p">})</span> <span class="k">do</span>
    <span class="c1"># 3. We have replaced the names HashDict by the ETS table</span>
    <span class="n">ets</span>  <span class="p">=</span> <span class="ss">:ets</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="p">[</span><span class="ss">:named_table</span><span class="p">,</span> <span class="ss">read_concurrency</span><span class="p">:</span> <span class="no">true</span><span class="p">])</span>
    <span class="n">refs</span> <span class="p">=</span> <span class="nc">HashDict</span><span class="p">.</span><span class="n">new</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">%{</span><span class="ss">names</span><span class="p">:</span> <span class="n">ets</span><span class="p">,</span> <span class="ss">refs</span><span class="p">:</span> <span class="n">refs</span><span class="p">,</span> <span class="ss">events</span><span class="p">:</span> <span class="n">events</span><span class="p">,</span> <span class="ss">buckets</span><span class="p">:</span> <span class="n">buckets</span><span class="p">}}</span>
  <span class="k">end</span>

  <span class="c1"># 4. The previous handle_call callback for lookup was removed</span>

  <span class="kd">def</span> <span class="n">handle_cast</span><span class="p">({</span><span class="ss">:create</span><span class="p">,</span> <span class="n">name</span><span class="p">},</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
    <span class="c1"># 5. Read and write to the ETS table instead of the HashDict</span>
    <span class="k">case</span> <span class="n">lookup</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">do</span>
      <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">_pid</span><span class="p">}</span> <span class="p">-&gt;</span>
        <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">state</span><span class="p">}</span>
      <span class="ss">:error</span> <span class="p">-&gt;</span>
        <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">pid</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Bucket.Supervisor</span><span class="p">.</span><span class="n">start_bucket</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">buckets</span><span class="p">)</span>
        <span class="n">ref</span> <span class="p">=</span> <span class="nc">Process</span><span class="p">.</span><span class="n">monitor</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
        <span class="n">refs</span> <span class="p">=</span> <span class="nc">HashDict</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">refs</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="ss">:ets</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">names</span><span class="p">,</span> <span class="p">{</span><span class="n">name</span><span class="p">,</span> <span class="n">pid</span><span class="p">})</span>
        <span class="nc">GenEvent</span><span class="p">.</span><span class="n">sync_notify</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">events</span><span class="p">,</span> <span class="p">{</span><span class="ss">:create</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">pid</span><span class="p">})</span>
        <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="p">%{</span><span class="n">state</span> <span class="p">|</span> <span class="ss">refs</span><span class="p">:</span> <span class="n">refs</span><span class="p">}}</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">handle_info</span><span class="p">({</span><span class="ss">:DOWN</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="ss">:process</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">_reason</span><span class="p">},</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
    <span class="c1"># 6. Delete from the ETS table instead of the HashDict</span>
    <span class="p">{</span><span class="n">name</span><span class="p">,</span> <span class="n">refs</span><span class="p">}</span> <span class="p">=</span> <span class="nc">HashDict</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">refs</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span>
    <span class="ss">:ets</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="nc">GenEvent</span><span class="p">.</span><span class="n">sync_notify</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">events</span><span class="p">,</span> <span class="p">{</span><span class="ss">:exit</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">pid</span><span class="p">})</span>
    <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="p">%{</span><span class="n">state</span> <span class="p">|</span> <span class="ss">refs</span><span class="p">:</span> <span class="n">refs</span><span class="p">}}</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">handle_info</span><span class="p">(</span><span class="n">_msg</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">state</span><span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Notice that before our changes <code>KV.Registry.lookup/2</code> sent requests to the server, but now it reads directly from the ETS table, which is shared across all processes. That&#39;s the main idea behind the cache mechanism we are implementing.</p>

<p>In order for the cache mechanism to work, the created ETS table needs to have access <code>:protected</code> (the default), so all clients can read from it, while only the <code>KV.Registry</code> process writes to it. We have also set <code>read_concurrency: true</code> when starting the table, optimizing the table for the common scenario of concurrent read operations.</p>

<p>The changes we have performed above have definitely broken our tests. For starters, there is a new argument we need to pass to <code>KV.Registry.start_link/3</code>. Let&#39;s start amending our tests in <code>test/kv/registry_test.exs</code> by rewriting the <code>setup</code> callback:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">setup</span> <span class="k">do</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">sup</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Bucket.Supervisor</span><span class="p">.</span><span class="n">start_link</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">manager</span><span class="p">}</span> <span class="p">=</span> <span class="nc">GenEvent</span><span class="p">.</span><span class="n">start_link</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">registry</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">start_link</span><span class="p">(</span><span class="ss">:registry_table</span><span class="p">,</span> <span class="n">manager</span><span class="p">,</span> <span class="n">sup</span><span class="p">)</span>

  <span class="nc">GenEvent</span><span class="p">.</span><span class="n">add_mon_handler</span><span class="p">(</span><span class="n">manager</span><span class="p">,</span> <span class="nc">Forwarder</span><span class="p">,</span> <span class="n">self</span><span class="p">())</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="ss">registry</span><span class="p">:</span> <span class="n">registry</span><span class="p">,</span> <span class="ss">ets</span><span class="p">:</span> <span class="ss">:registry_table</span><span class="p">}</span>
<span class="k">end</span>
</code></pre></div>
<p>Notice we are passing the table name of <code>:registry_table</code> to <code>KV.Registry.start_link/3</code> as well as returning <code>ets: :registry_table</code> as part of the test context.</p>

<p>After changing the callback above, we will still have failures in our test suite. All in the format of:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1) test spawns buckets (KV.RegistryTest)
   test/kv/registry_test.exs:38
   ** (ArgumentError) argument error
   stacktrace:
     (stdlib) :ets.lookup(#PID&lt;0.99.0&gt;, &quot;shopping&quot;)
     (kv) lib/kv/registry.ex:22: KV.Registry.lookup/2
     test/kv/registry_test.exs:39
</code></pre></div>
<p>This is happening because we are passing the registry pid to <code>KV.Registry.lookup/2</code> while now it expects the ETS table. We can fix this by changing all occurrences of:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="p">...)</span>
</code></pre></div>
<p>to:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="p">...)</span>
</code></pre></div>
<p>Where <code>ets</code> will be retrieved in the same way we retrieve the registry:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">test</span> <span class="s2">&quot;spawns buckets&quot;</span><span class="p">,</span> <span class="p">%{</span><span class="ss">registry</span><span class="p">:</span> <span class="n">registry</span><span class="p">,</span> <span class="ss">ets</span><span class="p">:</span> <span class="n">ets</span><span class="p">}</span> <span class="k">do</span>
</code></pre></div>
<p>Let&#39;s change our tests to pass <code>ets</code> to <code>lookup/2</code>. Once we finish these changes, some tests will continue to fail. You may even notice tests pass and fail inconsistently between runs. For example, the &quot;spawns buckets&quot; test:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">test</span> <span class="s2">&quot;spawns buckets&quot;</span><span class="p">,</span> <span class="p">%{</span><span class="ss">registry</span><span class="p">:</span> <span class="n">registry</span><span class="p">,</span> <span class="ss">ets</span><span class="p">:</span> <span class="n">ets</span><span class="p">}</span> <span class="k">do</span>
  <span class="n">assert</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="ss">:error</span>

  <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>
  <span class="n">assert</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>

  <span class="nc">KV.Bucket</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="s2">&quot;milk&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">assert</span> <span class="nc">KV.Bucket</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="s2">&quot;milk&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="k">end</span>
</code></pre></div>
<p>may be failing on this line:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">assert</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>
</code></pre></div>
<p>However how can this line fail if we just created the bucket in the previous line?</p>

<p>The reason those failures are happening is because, for didactic purposes, we have made two mistakes:</p>

<ol>
<li>We are prematurely optimizing (by adding this cache layer)</li>
<li>We are using <code>cast/2</code> (while we should be using <code>call/2</code>)</li>
</ol>

<h2 id="6.2-race-conditions?">6.2 Race conditions?</h2>

<p>Developing in Elixir does not make your code free of race conditions. However, Elixir&#39;s simple abstractions where nothing is shared by default make it easier to spot a race condition&#39;s root cause.</p>

<p>What is happening in our test is that there is a delay in between an operation and the time we can observe this change in the ETS table. Here is what we were expecting to happen:</p>

<ol>
<li>We invoke <code>KV.Registry.create(registry, &quot;shopping&quot;)</code></li>
<li>The registry creates the bucket and updates the cache table</li>
<li>We access the information from the table with <code>KV.Registry.lookup(ets, &quot;shopping&quot;)</code></li>
<li>The command above returns <code>{:ok, bucket}</code></li>
</ol>

<p>However, since <code>KV.Registry.create/2</code> is a cast operation, the command will return before we actually write to the table! In other words, this is happening:</p>

<ol>
<li>We invoke <code>KV.Registry.create(registry, &quot;shopping&quot;)</code></li>
<li>We access the information from the table with <code>KV.Registry.lookup(ets, &quot;shopping&quot;)</code></li>
<li>The command above returns <code>:error</code></li>
<li>The registry creates the bucket and updates the cache table</li>
</ol>

<p>To fix the failure we just need to make <code>KV.Registry.create/2</code> synchronous by using <code>call/2</code> rather than <code>cast/2</code>. This will guarantee that the client will only continue after changes have been made to the table. Let&#39;s change the function and its callback as follows:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">create</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">do</span>
  <span class="nc">GenServer</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="p">{</span><span class="ss">:create</span><span class="p">,</span> <span class="n">name</span><span class="p">})</span>
<span class="k">end</span>

<span class="kd">def</span> <span class="n">handle_call</span><span class="p">({</span><span class="ss">:create</span><span class="p">,</span> <span class="n">name</span><span class="p">},</span> <span class="n">_from</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">case</span> <span class="n">lookup</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">pid</span><span class="p">}</span> <span class="p">-&gt;</span>
      <span class="p">{</span><span class="ss">:reply</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">state</span><span class="p">}</span> <span class="c1"># Reply with pid</span>
    <span class="ss">:error</span> <span class="p">-&gt;</span>
      <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">pid</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Bucket.Supervisor</span><span class="p">.</span><span class="n">start_bucket</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">buckets</span><span class="p">)</span>
      <span class="n">ref</span> <span class="p">=</span> <span class="nc">Process</span><span class="p">.</span><span class="n">monitor</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
      <span class="n">refs</span> <span class="p">=</span> <span class="nc">HashDict</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">refs</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
      <span class="ss">:ets</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">names</span><span class="p">,</span> <span class="p">{</span><span class="n">name</span><span class="p">,</span> <span class="n">pid</span><span class="p">})</span>
      <span class="nc">GenEvent</span><span class="p">.</span><span class="n">sync_notify</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">events</span><span class="p">,</span> <span class="p">{</span><span class="ss">:create</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">pid</span><span class="p">})</span>
      <span class="p">{</span><span class="ss">:reply</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="p">%{</span><span class="n">state</span> <span class="p">|</span> <span class="ss">refs</span><span class="p">:</span> <span class="n">refs</span><span class="p">}}</span> <span class="c1"># Reply with pid</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>We simply changed the callback from <code>handle_cast/2</code> to <code>handle_call/3</code> and changed it to reply with the pid of the created bucket.</p>

<p>Let&#39;s run the tests once again. This time though, we will pass the <code>--trace</code> option:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ mix test --trace
</code></pre></div>
<p>The <code>--trace</code> option is useful when your tests are deadlocking or there are race conditions, as it runs all tests synchronously (<code>async: true</code> has no effect) and shows detailed information about each test. This time we should be down to one failure (that may be intermittent):</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1) test removes buckets on exit (KV.RegistryTest)
   test/kv/registry_test.exs:48
   Assertion with == failed
   code: KV.Registry.lookup(ets, &quot;shopping&quot;) == :error
   lhs:  {:ok, #PID&lt;0.103.0&gt;}
   rhs:  :error
   stacktrace:
     test/kv/registry_test.exs:52
</code></pre></div>
<p>According to the failure message, we are expecting that the bucket no longer exists on the table, but it still does! This problem is the opposite of the one we have just solved: while previously there was a delay between the command to create a bucket and updating the table, now there is a delay between the bucket process dying and its entry being removed from the table.</p>

<p>Unfortunately this time we cannot simply change <code>handle_info/2</code> to a synchronous operation. We can, however, fix our tests by using event manager notifications. Let&#39;s take another look at our <code>handle_info/2</code> implementation:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">handle_info</span><span class="p">({</span><span class="ss">:DOWN</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="ss">:process</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">_reason</span><span class="p">},</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># 5. Delete from the ETS table instead of the HashDict</span>
  <span class="p">{</span><span class="n">name</span><span class="p">,</span> <span class="n">refs</span><span class="p">}</span> <span class="p">=</span> <span class="nc">HashDict</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">refs</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span>
  <span class="ss">:ets</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
  <span class="nc">GenEvent</span><span class="p">.</span><span class="n">sync_notify</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">event</span><span class="p">,</span> <span class="p">{</span><span class="ss">:exit</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">pid</span><span class="p">})</span>
  <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="p">%{</span><span class="n">state</span> <span class="p">|</span> <span class="ss">refs</span><span class="p">:</span> <span class="n">refs</span><span class="p">}}</span>
<span class="k">end</span>
</code></pre></div>
<p>Notice that we are deleting from the ETS table <strong>before</strong> we send the notification. This is by design! This means that when we receive the <code>{:exit, name, pid}</code> notification, the table will already be up to date. Let&#39;s update the remaining failing test as follows:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">test</span> <span class="s2">&quot;removes buckets on exit&quot;</span><span class="p">,</span> <span class="p">%{</span><span class="ss">registry</span><span class="p">:</span> <span class="n">registry</span><span class="p">,</span> <span class="ss">ets</span><span class="p">:</span> <span class="n">ets</span><span class="p">}</span> <span class="k">do</span>
  <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>
  <span class="nc">Agent</span><span class="p">.</span><span class="n">stop</span><span class="p">(</span><span class="n">bucket</span><span class="p">)</span>
  <span class="n">assert_receive</span> <span class="p">{</span><span class="ss">:exit</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">,</span> <span class="o">^</span><span class="n">bucket</span><span class="p">}</span> <span class="c1"># Wait for event</span>
  <span class="n">assert</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="ss">:error</span>
<span class="k">end</span>
</code></pre></div>
<p>We have simply amended the test to guarantee we first receive the <code>{:exit, name, pid}</code> message before invoking <code>KV.Registry.lookup/2</code>.</p>

<p>It is important to observe that we were able to keep our suite passing without a need to use <code>:timer.sleep/1</code> or other tricks. Most of the time, we can rely on events, monitoring and messages to assert the system is in an expected state before performing assertions.</p>

<p>For your convenience, here is the fully passing test case:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">KV.RegistryTest</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="nc">ExUnit.Case</span><span class="p">,</span> <span class="ss">async</span><span class="p">:</span> <span class="no">true</span>

  <span class="kd">defmodule</span> <span class="nc">Forwarder</span> <span class="k">do</span>
    <span class="kn">use</span> <span class="nc">GenEvent</span>

    <span class="kd">def</span> <span class="n">handle_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">send</span> <span class="n">parent</span><span class="p">,</span> <span class="n">event</span>
      <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">parent</span><span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">setup</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">sup</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Bucket.Supervisor</span><span class="p">.</span><span class="n">start_link</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">manager</span><span class="p">}</span> <span class="p">=</span> <span class="nc">GenEvent</span><span class="p">.</span><span class="n">start_link</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">registry</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">start_link</span><span class="p">(</span><span class="ss">:registry_table</span><span class="p">,</span> <span class="n">manager</span><span class="p">,</span> <span class="n">sup</span><span class="p">)</span>

    <span class="nc">GenEvent</span><span class="p">.</span><span class="n">add_mon_handler</span><span class="p">(</span><span class="n">manager</span><span class="p">,</span> <span class="nc">Forwarder</span><span class="p">,</span> <span class="n">self</span><span class="p">())</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="ss">registry</span><span class="p">:</span> <span class="n">registry</span><span class="p">,</span> <span class="ss">ets</span><span class="p">:</span> <span class="ss">:registry_table</span><span class="p">}</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="s2">&quot;sends events on create and crash&quot;</span><span class="p">,</span> <span class="p">%{</span><span class="ss">registry</span><span class="p">:</span> <span class="n">registry</span><span class="p">,</span> <span class="ss">ets</span><span class="p">:</span> <span class="n">ets</span><span class="p">}</span> <span class="k">do</span>
    <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>
    <span class="n">assert_receive</span> <span class="p">{</span><span class="ss">:create</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">,</span> <span class="o">^</span><span class="n">bucket</span><span class="p">}</span>

    <span class="nc">Agent</span><span class="p">.</span><span class="n">stop</span><span class="p">(</span><span class="n">bucket</span><span class="p">)</span>
    <span class="n">assert_receive</span> <span class="p">{</span><span class="ss">:exit</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">,</span> <span class="o">^</span><span class="n">bucket</span><span class="p">}</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="s2">&quot;spawns buckets&quot;</span><span class="p">,</span> <span class="p">%{</span><span class="ss">registry</span><span class="p">:</span> <span class="n">registry</span><span class="p">,</span> <span class="ss">ets</span><span class="p">:</span> <span class="n">ets</span><span class="p">}</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="ss">:error</span>

    <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>
    <span class="n">assert</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>

    <span class="nc">KV.Bucket</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="s2">&quot;milk&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">assert</span> <span class="nc">KV.Bucket</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="s2">&quot;milk&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="s2">&quot;removes buckets on exit&quot;</span><span class="p">,</span> <span class="p">%{</span><span class="ss">registry</span><span class="p">:</span> <span class="n">registry</span><span class="p">,</span> <span class="ss">ets</span><span class="p">:</span> <span class="n">ets</span><span class="p">}</span> <span class="k">do</span>
    <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>
    <span class="nc">Agent</span><span class="p">.</span><span class="n">stop</span><span class="p">(</span><span class="n">bucket</span><span class="p">)</span>
    <span class="n">assert_receive</span> <span class="p">{</span><span class="ss">:exit</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">,</span> <span class="o">^</span><span class="n">bucket</span><span class="p">}</span> <span class="c1"># Wait for event</span>
    <span class="n">assert</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="ss">:error</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="s2">&quot;removes bucket on crash&quot;</span><span class="p">,</span> <span class="p">%{</span><span class="ss">registry</span><span class="p">:</span> <span class="n">registry</span><span class="p">,</span> <span class="ss">ets</span><span class="p">:</span> <span class="n">ets</span><span class="p">}</span> <span class="k">do</span>
    <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>

    <span class="c1"># Kill the bucket and wait for the notification</span>
    <span class="nc">Process</span><span class="p">.</span><span class="n">exit</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="ss">:shutdown</span><span class="p">)</span>
    <span class="n">assert_receive</span> <span class="p">{</span><span class="ss">:exit</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">,</span> <span class="o">^</span><span class="n">bucket</span><span class="p">}</span>
    <span class="n">assert</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="ss">:error</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>With tests passing, we just need to update the supervisor <code>init/1</code> callback at <code>lib/kv/supervisor.ex</code> to pass the ETS table name as an argument to the registry worker:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="na">@manager_name</span> <span class="nc">KV.EventManager</span>
<span class="na">@registry_name</span> <span class="nc">KV.Registry</span>
<span class="na">@ets_registry_name</span> <span class="nc">KV.Registry</span>
<span class="na">@bucket_sup_name</span> <span class="nc">KV.Bucket.Supervisor</span>

<span class="kd">def</span> <span class="n">init</span><span class="p">(</span><span class="ss">:ok</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">children</span> <span class="p">=</span> <span class="p">[</span>
    <span class="n">worker</span><span class="p">(</span><span class="nc">GenEvent</span><span class="p">,</span> <span class="p">[[</span><span class="ss">name</span><span class="p">:</span> <span class="na">@manager_name</span><span class="p">]]),</span>
    <span class="n">supervisor</span><span class="p">(</span><span class="nc">KV.Bucket.Supervisor</span><span class="p">,</span> <span class="p">[[</span><span class="ss">name</span><span class="p">:</span> <span class="na">@bucket_sup_name</span><span class="p">]]),</span>
    <span class="n">worker</span><span class="p">(</span><span class="nc">KV.Registry</span><span class="p">,</span> <span class="p">[</span><span class="na">@ets_registry_name</span><span class="p">,</span> <span class="na">@manager_name</span><span class="p">,</span>
                         <span class="na">@bucket_sup_name</span><span class="p">,</span> <span class="p">[</span><span class="ss">name</span><span class="p">:</span> <span class="na">@registry_name</span><span class="p">]])</span>
  <span class="p">]</span>

  <span class="n">supervise</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="ss">strategy</span><span class="p">:</span> <span class="ss">:one_for_one</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>Note that we are using <code>KV.Registry</code> as name for the ETS table as well, which makes it convenient to debug, as it points to the module using it. ETS names and process names are stored in different registries, so there is no chance of conflicts.</p>

<h2 id="6.3-ets-as-persistent-storage">6.3 ETS as persistent storage</h2>

<p>So far we have created an ETS table during the registry initialization but we haven&#39;t bothered to close the table on registry termination. That&#39;s because the ETS table is &quot;linked&quot; (in a figure of speech) to the process that creates it. If that process dies, the table is automatically closed.</p>

<p>This is extremely convenient as a default behaviour, and we can use it even more to our advantage. Remember that there is a dependency between the registry and the buckets supervisor. If the registry dies, we want the buckets supervisor to die too, because once the registry dies all information linking the bucket name to the bucket process is lost. However, what if we could keep the registry data even if the registry process crashes? If we are able to do so, we remove the dependency between the registry and the buckets supervisor, making the <code>:one_for_one</code> strategy the perfect strategy for our supevisor.</p>

<p>A couple of changes will be required in order to make this happen. First, we&#39;ll need to start the ETS table inside the supervisor. Second, we&#39;ll need to change the table&#39;s access type from <code>:protected</code> to <code>:public</code>, because the owner is the supervisor, but the process doing the writes is still the manager.</p>

<p>Let&#39;s get started by first changing <code>KV.Supervisor</code>&#39;s <code>init/1</code> callback:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">init</span><span class="p">(</span><span class="ss">:ok</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">ets</span> <span class="p">=</span> <span class="ss">:ets</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="na">@ets_registry_name</span><span class="p">,</span>
                 <span class="p">[</span><span class="ss">:set</span><span class="p">,</span> <span class="ss">:public</span><span class="p">,</span> <span class="ss">:named_table</span><span class="p">,</span> <span class="p">{</span><span class="ss">:read_concurrency</span><span class="p">,</span> <span class="no">true</span><span class="p">}])</span>

  <span class="n">children</span> <span class="p">=</span> <span class="p">[</span>
    <span class="n">worker</span><span class="p">(</span><span class="nc">GenEvent</span><span class="p">,</span> <span class="p">[[</span><span class="ss">name</span><span class="p">:</span> <span class="na">@manager_name</span><span class="p">]]),</span>
    <span class="n">supervisor</span><span class="p">(</span><span class="nc">KV.Bucket.Supervisor</span><span class="p">,</span> <span class="p">[[</span><span class="ss">name</span><span class="p">:</span> <span class="na">@bucket_sup_name</span><span class="p">]]),</span>
    <span class="n">worker</span><span class="p">(</span><span class="nc">KV.Registry</span><span class="p">,</span> <span class="p">[</span><span class="n">ets</span><span class="p">,</span> <span class="na">@manager_name</span><span class="p">,</span>
                         <span class="na">@bucket_sup_name</span><span class="p">,</span> <span class="p">[</span><span class="ss">name</span><span class="p">:</span> <span class="na">@registry_name</span><span class="p">]])</span>
  <span class="p">]</span>

  <span class="n">supervise</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="ss">strategy</span><span class="p">:</span> <span class="ss">:one_for_one</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>Next, we change <code>KV.Registry</code>&#39;s <code>init/1</code> callback, as it no longer needs to create a table. It should instead just use the one given as an argument:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">init</span><span class="p">({</span><span class="n">table</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">buckets</span><span class="p">})</span> <span class="k">do</span>
  <span class="n">refs</span> <span class="p">=</span> <span class="nc">HashDict</span><span class="p">.</span><span class="n">new</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">%{</span><span class="ss">names</span><span class="p">:</span> <span class="n">table</span><span class="p">,</span> <span class="ss">refs</span><span class="p">:</span> <span class="n">refs</span><span class="p">,</span> <span class="ss">events</span><span class="p">:</span> <span class="n">events</span><span class="p">,</span> <span class="ss">buckets</span><span class="p">:</span> <span class="n">buckets</span><span class="p">}}</span>
<span class="k">end</span>
</code></pre></div>
<p>Finally, we just need to change the <code>setup</code> callback in <code>test/kv/registry_test.exs</code> to explicitly create the ETS table. We will use this opportunity to also split the <code>setup</code> functionality into a private function that will be handy soon:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">setup</span> <span class="k">do</span>
  <span class="n">ets</span> <span class="p">=</span> <span class="ss">:ets</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:registry_table</span><span class="p">,</span> <span class="p">[</span><span class="ss">:set</span><span class="p">,</span> <span class="ss">:public</span><span class="p">])</span>
  <span class="n">registry</span> <span class="p">=</span> <span class="n">start_registry</span><span class="p">(</span><span class="n">ets</span><span class="p">)</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="ss">registry</span><span class="p">:</span> <span class="n">registry</span><span class="p">,</span> <span class="ss">ets</span><span class="p">:</span> <span class="n">ets</span><span class="p">}</span>
<span class="k">end</span>

<span class="kd">defp</span> <span class="n">start_registry</span><span class="p">(</span><span class="n">ets</span><span class="p">)</span> <span class="k">do</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">sup</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Bucket.Supervisor</span><span class="p">.</span><span class="n">start_link</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">manager</span><span class="p">}</span> <span class="p">=</span> <span class="nc">GenEvent</span><span class="p">.</span><span class="n">start_link</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">registry</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">start_link</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="n">manager</span><span class="p">,</span> <span class="n">sup</span><span class="p">)</span>

  <span class="nc">GenEvent</span><span class="p">.</span><span class="n">add_mon_handler</span><span class="p">(</span><span class="n">manager</span><span class="p">,</span> <span class="nc">Forwarder</span><span class="p">,</span> <span class="n">self</span><span class="p">())</span>
  <span class="n">registry</span>
<span class="k">end</span>
</code></pre></div>
<p>After those changes, our test suite should continue to be green!</p>

<p>There is just one last scenario to consider: once we receive the ETS table, there may be existing bucket pids on the table. After all, that&#39;s the whole purpose of this change! However, the newly started registry is not monitoring those buckets, as they were created as part of previous, now defunct, registry. This means that the table may go stale, because we won&#39;t remove those buckets if they die.</p>

<p>Let&#39;s add a test to <code>test/kv/registry_test.exs</code> that shows this bug:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">test</span> <span class="s2">&quot;monitors existing entries&quot;</span><span class="p">,</span> <span class="p">%{</span><span class="ss">registry</span><span class="p">:</span> <span class="n">registry</span><span class="p">,</span> <span class="ss">ets</span><span class="p">:</span> <span class="n">ets</span><span class="p">}</span> <span class="k">do</span>
  <span class="n">bucket</span> <span class="p">=</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>

  <span class="c1"># Kill the registry. We unlink first, otherwise it will kill the test</span>
  <span class="nc">Process</span><span class="p">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">registry</span><span class="p">)</span>
  <span class="nc">Process</span><span class="p">.</span><span class="n">exit</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="ss">:shutdown</span><span class="p">)</span>

  <span class="c1"># Start a new registry with the existing table and access the bucket</span>
  <span class="n">start_registry</span><span class="p">(</span><span class="n">ets</span><span class="p">)</span>
  <span class="n">assert</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span>

  <span class="c1"># Once the bucket dies, we should receive notifications</span>
  <span class="nc">Process</span><span class="p">.</span><span class="n">exit</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="ss">:shutdown</span><span class="p">)</span>
  <span class="n">assert_receive</span> <span class="p">{</span><span class="ss">:exit</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">,</span> <span class="o">^</span><span class="n">bucket</span><span class="p">}</span>
  <span class="n">assert</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="ss">:error</span>
<span class="k">end</span>
</code></pre></div>
<p>Run the new test and it will fail with:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1) test monitors existing entries (KV.RegistryTest)
   test/kv/registry_test.exs:72
   No message matching {:exit, &quot;shopping&quot;, ^bucket}
   stacktrace:
     test/kv/registry_test.exs:85
</code></pre></div>
<p>That&#39;s what we expected. If the bucket is not being monitored, the registry is not notified when it dies and therefore no event is sent. We can fix this by changing <code>KV.Registry</code>&#39;s <code>init/1</code> callback one last time to setup monitors for all existing entries in the table:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">init</span><span class="p">({</span><span class="n">table</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">buckets</span><span class="p">})</span> <span class="k">do</span>
  <span class="n">refs</span> <span class="p">=</span> <span class="ss">:ets</span><span class="p">.</span><span class="n">foldl</span><span class="p">(</span><span class="k">fn</span> <span class="p">{</span><span class="n">name</span><span class="p">,</span> <span class="n">pid</span><span class="p">},</span> <span class="n">acc</span> <span class="p">-&gt;</span>
    <span class="nc">HashDict</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="nc">Process</span><span class="p">.</span><span class="n">monitor</span><span class="p">(</span><span class="n">pid</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>
  <span class="k">end</span><span class="p">,</span> <span class="nc">HashDict</span><span class="p">.</span><span class="n">new</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>

  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">%{</span><span class="ss">names</span><span class="p">:</span> <span class="n">table</span><span class="p">,</span> <span class="ss">refs</span><span class="p">:</span> <span class="n">refs</span><span class="p">,</span> <span class="ss">events</span><span class="p">:</span> <span class="n">events</span><span class="p">,</span> <span class="ss">buckets</span><span class="p">:</span> <span class="n">buckets</span><span class="p">}}</span>
<span class="k">end</span>
</code></pre></div>
<p>We use <code>:ets.foldl/3</code> to go through all entries in the table, similar to <code>Enum.reduce/3</code>, invoking the given function for each element in the table with the given accumulator. In the function callback, we monitor each pid in the table and update the refs dictionary accordingly. If any of the entries is already dead, we will still receive the <code>:DOWN</code> message, causing them to be purged later.</p>

<p>In this chapter we were able to make our application more robust by using an ETS table that is owned by the supervisor and passed to the registry. We have also explored how to use ETS as a cache and discussed some of the race conditions we may run into as data becomes shared between the server and all clients.</p>

  </article><!-- .hfeed -->

  
</div><!-- #content -->


  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-8268430-6']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>

  <script src="../../../ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <script src="../../js/toc/toc.js" type="text/javascript" charset="utf-8"></script>
  <script type="text/javascript">
    $(document).ready(function() {
        $('.toc').toc({
          title: '',
          listType: 'ul',
          minimumHeaders: 2,
          headers: 'h2, h3, h4, h5, h6',
          showSpeed: 0,
        });
    });
  </script>
</body>
</html>

