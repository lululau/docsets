<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <title>5 Supervisor and Application - Elixir</title>
  <link href="http://feeds.feedburner.com/ElixirLang" rel="alternate" title="Elixir's Blog" type="application/atom+xml" />
  <link rel="stylesheet" type="text/css" href="/css/style.css" />
  <link rel="stylesheet" type="text/css" href="/css/syntax.css" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" id="font-bitter-css" href="http://fonts.googleapis.com/css?family=Bitter&amp;ver=1" type="text/css" media="screen" />
</head>

<body class="getting_started">
<div id="content">
  <article>
    <h1 id="5-supervisor-and-application">5 Supervisor and Application</h1>

<div class="toc"></div>

<p>So far our application requires an event manager and a registry. It may potentially use dozens, if not hundreds, of buckets. While we may think our implementation so far is quite good, no software is bug free, and failures are definitely going to happen.</p>

<p>When things fail, your first reaction may be: &quot;let&#39;s rescue those errors&quot;. But, as we have learned in the Getting Started guide, in Elixir we don&#39;t have the defensive programming habit of rescuing exceptions, as commonly seen in other languages. Instead, we say &quot;fail fast&quot; or &quot;let it crash&quot;. If there is a bug that leads our registry to crash, we have nothing to worry about because we are going to setup a supervisor that will start a fresh copy of the registry.</p>

<p>In this chapter, we are going to learn about supervisors and also about applications. We are going to create not one, but two supervisors, and use them to supervise our processes.</p>

<h2 id="5.1-our-first-supervisor">5.1 Our first Supervisor</h2>

<p>Creating a supervisor is not much different from creating a GenServer. We are going to define a module named <code>KV.Supervisor</code>, which will use the <a href="/docs/stable/elixir/Supervisor.html">Supervisor</a> behaviour, inside the <code>lib/kv/supervisor.ex</code> file:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">KV.Supervisor</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="nc">Supervisor</span>

  <span class="kd">def</span> <span class="n">start_link</span> <span class="k">do</span>
    <span class="nc">Supervisor</span><span class="p">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="ss">:ok</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="na">@manager_name</span> <span class="nc">KV.EventManager</span>
  <span class="na">@registry_name</span> <span class="nc">KV.Registry</span>

  <span class="kd">def</span> <span class="n">init</span><span class="p">(</span><span class="ss">:ok</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">children</span> <span class="p">=</span> <span class="p">[</span>
      <span class="n">worker</span><span class="p">(</span><span class="nc">GenEvent</span><span class="p">,</span> <span class="p">[[</span><span class="ss">name</span><span class="p">:</span> <span class="na">@manager_name</span><span class="p">]]),</span>
      <span class="n">worker</span><span class="p">(</span><span class="nc">KV.Registry</span><span class="p">,</span> <span class="p">[</span><span class="na">@manager_name</span><span class="p">,</span> <span class="p">[</span><span class="ss">name</span><span class="p">:</span> <span class="na">@registry_name</span><span class="p">]])</span>
    <span class="p">]</span>

    <span class="n">supervise</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="ss">strategy</span><span class="p">:</span> <span class="ss">:one_for_one</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Our supervisor has two children: the event manager and the registry. It&#39;s common to give names to processes under supervision so that other processes can access them by name without needing to know their pid. This is useful because a supervised process might crash, in which case its pid will change when the supervisor restarts it. We declare the names of our supervisor&#39;s children by using the module attributes <code>@manager_name</code> and <code>@registry_name</code>, then reference those attributes in the worker definitions. While it&#39;s not required that we declare the names of our child processes in module attributes, it&#39;s helpful, because doing so helps make them stand out to the reader of our code.</p>

<p>For example, the <code>KV.Registry</code> worker receives two arguments, the first is the name of the event manager and the second is a keyword list of options. In this case, we set the name option to <code>[name: KV.Registry]</code> (using our previously-defined module attribute, <code>@registry_name</code>), guaranteeing we can access the registry by the name <code>KV.Registry</code> throughout the application. It is very common to name the children of a supervisor after the module that defines them, as this association becomes very handy when debugging a live system.</p>

<p>The order children are declared in the supervisor also matters. Since the registry depends on the event manager, we must start the latter before the former. That&#39;s why the <code>GenEvent</code> worker must come before the <code>KV.Registry</code> worker in the children list.</p>

<p>Finally, we call <code>supervise/2</code>, passing the list of children and the strategy of <code>:one_for_one</code>.</p>

<p>The supervision strategy dictates what happens when one of the children crashes. <code>:one_for_one</code> means that if a child dies only one is restarted to replace it. This strategy makes sense for now. If the event manager crashes, there is no reason to restart the registry and vice-versa. However, those dynamics may change once we add more children to supervisor. The <code>Supervisor</code> behaviour supports many different strategies and we will discuss three of them in this chapter.</p>

<p>If we start a console inside our project using <code>iex -S mix</code>, we can manually start the supervisor:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="nc">KV.Supervisor</span><span class="p">.</span><span class="n">start_link</span>
<span class="go">{:ok, #PID&lt;0.66.0&gt;}</span>
<span class="gp">iex&gt; </span><span class="nc">KV.Registry</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="nc">KV.Registry</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>
<span class="go">:ok</span>
<span class="gp">iex&gt; </span><span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="nc">KV.Registry</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>
<span class="go">{:ok, #PID&lt;0.70.0&gt;}</span>
</code></pre></div>
<p>When we started the supervisor tree, both the event manager and registry worker were automatically started, allowing us to create buckets without the need to manually start these processes.</p>

<p>In practice though, we rarely start the application supervisor manually. Instead it is started as part of the application callback.</p>

<h2 id="5.2-understanding-applications">5.2 Understanding applications</h2>

<p>We have been working inside an application this entire time. Every time we changed a file and ran <code>mix compile</code>, we could see <code>Generated kv.app</code> message in the compilation output.</p>

<p>We can find the generated <code>.app</code> file at <code>_build/dev/lib/kv/ebin/kv.app</code>. Let&#39;s have a look at its contents:</p>
<div class="highlight"><pre><code class="language-erlang" data-lang="erlang"><span class="p">{</span><span class="n">application</span><span class="p">,</span><span class="n">kv</span><span class="p">,</span>
             <span class="p">[{</span><span class="n">registered</span><span class="p">,[]},</span>
              <span class="p">{</span><span class="n">description</span><span class="p">,</span><span class="s">&quot;kv&quot;</span><span class="p">},</span>
              <span class="p">{</span><span class="n">applications</span><span class="p">,[</span><span class="n">kernel</span><span class="p">,</span><span class="n">stdlib</span><span class="p">,</span><span class="n">elixir</span><span class="p">,</span><span class="n">logger</span><span class="p">]},</span>
              <span class="p">{</span><span class="n">vsn</span><span class="p">,</span><span class="s">&quot;0.0.1&quot;</span><span class="p">},</span>
              <span class="p">{</span><span class="n">modules</span><span class="p">,[</span><span class="n">&#39;Elixir.KV&#39;</span><span class="p">,</span><span class="n">&#39;Elixir.KV.Bucket&#39;</span><span class="p">,</span>
                        <span class="n">&#39;Elixir.KV.Registry&#39;</span><span class="p">,</span><span class="n">&#39;Elixir.KV.Supervisor&#39;</span><span class="p">]}]}.</span>
</code></pre></div>
<p>This file contains Erlang terms (written using Erlang syntax). Even though we are not familiar with Erlang, it is easy to guess this file holds our application definition. It contains our application <code>version</code>, all the modules defined by it, as well as a list of applications we depend on, like Erlang&#39;s <code>kernel</code> and <code>elixir</code> itself, and <code>logger</code> which is specified in the application list in <code>mix.exs</code>.</p>

<p>It would be pretty boring to update this file manually every time we add a new module to our application. That&#39;s why mix generates and maintains it automatically for us.</p>

<p>We can also configure the generated <code>.app</code> file by customizing the values returned by the <code>application/0</code> inside our <code>mix.exs</code> project file. We will get to that in upcoming chapters.</p>

<h3 id="5.2.1-starting-applications">5.2.1 Starting applications</h3>

<p>When we define an <code>.app</code> file, which is the application definition, we are able to start and stop the application as a whole. We haven&#39;t worried about this so far for two reasons:</p>

<ol>
<li><p>Mix automatically starts our current application for us</p></li>
<li><p>Even if Mix didn&#39;t start our application for us, our application does not yet need to do anything when it starts</p></li>
</ol>

<p>In any case, let&#39;s see how Mix starts the application for us. Let&#39;s start a project console with <code>iex -S mix</code> and try:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="nc">Application</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="ss">:kv</span><span class="p">)</span>
<span class="go">{:error, {:already_started, :kv}}</span>
</code></pre></div>
<p>Oops, it&#39;s already started.</p>

<p>We can pass an option to mix to ask it to not start our application. Let&#39;s give it a try by running <code>iex -S mix run --no-start</code>:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">iex</span><span class="o">&gt;</span> <span class="nc">Application</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="ss">:kv</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="p">{</span><span class="ss">:not_started</span><span class="p">,</span> <span class="ss">:logger</span><span class="p">}}</span>
</code></pre></div>
<p>Now we get an error because an application that <code>:kv</code> depends on (<code>:logger</code> in this case) hasn&#39;t been started. Mix normally starts the whole hierarchy of applications defined in our project&#39;s <code>mix.exs</code> file and it does the same for all dependencies if they depend on other applications. But since we passed the <code>--no-start</code> flag, we need to either start each application manually in the correct order or call <code>Application.ensure_all_started</code> as follows:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">iex</span><span class="o">&gt;</span> <span class="nc">Application</span><span class="p">.</span><span class="n">ensure_all_started</span><span class="p">(</span><span class="ss">:kv</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">[</span><span class="ss">:logger</span><span class="p">,</span> <span class="ss">:kv</span><span class="p">]}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="nc">Application</span><span class="p">.</span><span class="n">stop</span><span class="p">(</span><span class="ss">:kv</span><span class="p">)</span>
<span class="mi">18</span><span class="err">:</span><span class="mi">12</span><span class="err">:</span><span class="mf">10.698</span> <span class="p">[</span><span class="n">info</span><span class="p">]</span> <span class="nc">Application</span> <span class="n">kv</span> <span class="n">exited</span> <span class="ss">:stopped</span>
<span class="ss">:ok</span>
</code></pre></div>
<p>Nothing really exciting happens but it shows how we can control our application.</p>

<blockquote>
<p>When you run <code>iex -S mix</code>, it is equivalent to running <code>iex -S mix run</code>. So whenever you need to pass more options to mix when starting iex, it&#39;s just a matter of typing <code>mix run</code> and then passing any options the <code>run</code> command accepts. You can find more information about <code>run</code> by running <code>mix help run</code> in your shell.</p>
</blockquote>

<h3 id="5.2.2-the-application-callback">5.2.2 The application callback</h3>

<p>Since we spent all this time talking about how applications are started and stopped, there must be a way to do something useful when the application starts. And indeed, there is!</p>

<p>We can specify an application callback function. This is a function that will be invoked when the application starts. The function must return a result of <code>{:ok, pid}</code>, where <code>pid</code> is the process identifier of a supervisor process.</p>

<p>We can configure the application callback in two steps. First, open up the <code>mix.exs</code> file and change <code>def application</code> to the following:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">application</span> <span class="k">do</span>
  <span class="p">[</span><span class="ss">applications</span><span class="p">:</span> <span class="p">[],</span>
   <span class="ss">mod</span><span class="p">:</span> <span class="p">{</span><span class="nc">KV</span><span class="p">,</span> <span class="p">[]}]</span>
<span class="k">end</span>
</code></pre></div>
<p>The <code>:mod</code> option specifies the &quot;application callback module&quot;, followed by the arguments to be passed on application start. The application callback module can be any module that implements the <a href="/docs/stable/elixir/Application.html">Application</a> behaviour.</p>

<p>Now that we have specified <code>KV</code> as the module callback, we need to change the <code>KV</code> module, defined in <code>lib/kv.ex</code>:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">KV</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="nc">Application</span>

  <span class="kd">def</span> <span class="n">start</span><span class="p">(</span><span class="n">_type</span><span class="p">,</span> <span class="n">_args</span><span class="p">)</span> <span class="k">do</span>
    <span class="nc">KV.Supervisor</span><span class="p">.</span><span class="n">start_link</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>When we <code>use Application</code>, we only need to define a <code>start/2</code> function. If we wanted to specify custom behaviour on application stop, we could define a <code>stop/1</code> function, as well. In this case, the one automatically defined by <code>use Application</code> is fine.</p>

<p>Let&#39;s start our project console once again with <code>iex -S mix</code>. We will see a process named <code>KV.Registry</code> is already running:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="nc">KV.Registry</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="nc">KV.Registry</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>
<span class="go">:ok</span>
<span class="gp">iex&gt; </span><span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="nc">KV.Registry</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>
<span class="go">{:ok, #PID&lt;0.88.0&gt;}</span>
</code></pre></div>
<p>Excellent!</p>

<h3 id="5.2.3-projects-or-applications?">5.2.3 Projects or applications?</h3>

<p>Mix makes a distinction between projects and applications. Based on the current contents of our <code>mix.exs</code> file, we would say we have a Mix project that defines the <code>:kv</code> application. As we will see in later chapters, there are projects that don&#39;t define any application.</p>

<p>When we say &quot;project,&quot; you should think about Mix. Mix is the tool that manages your project. It knows how to compile your project, test your project and more. It also knows how to compile and start the application relevant to your project.</p>

<p>When we talk about applications, we talk about OTP. Applications are the entities that are started and stopped as a whole by the runtime. You can learn more about applications in the <a href="/docs/stable/elixir/Application.html">docs for the Application module</a>, as well as by running <code>mix help compile.app</code> to learn more about the supported options in <code>def application</code>.</p>

<h2 id="5.3-simple-one-for-one-supervisors">5.3 Simple one for one supervisors</h2>

<p>We have now successfully defined our supervisor which is automatically started (and stopped) as part of our application lifecycle.</p>

<p>Remember however that our <code>KV.Registry</code> is both linking and monitoring bucket processes in the <code>handle_cast/2</code> callback:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">pid</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Bucket</span><span class="p">.</span><span class="n">start_link</span><span class="p">()</span>
<span class="n">ref</span> <span class="p">=</span> <span class="nc">Process</span><span class="p">.</span><span class="n">monitor</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
</code></pre></div>
<p>Links are bi-directional, which implies that a crash in a bucket will crash the registry. Although we now have the supervisor, which guarantees the registry will be back up and running, crashing the registry still means we lose all data associating bucket names to their respective processes.</p>

<p>In other words, we want the registry to keep on running even if a bucket crashes. Let&#39;s write a test:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">test</span> <span class="s2">&quot;removes bucket on crash&quot;</span><span class="p">,</span> <span class="p">%{</span><span class="ss">registry</span><span class="p">:</span> <span class="n">registry</span><span class="p">}</span> <span class="k">do</span>
  <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span>

  <span class="c1"># Kill the bucket and wait for the notification</span>
  <span class="nc">Process</span><span class="p">.</span><span class="n">exit</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="ss">:shutdown</span><span class="p">)</span>
  <span class="n">assert_receive</span> <span class="p">{</span><span class="ss">:exit</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">,</span> <span class="o">^</span><span class="n">bucket</span><span class="p">}</span>
  <span class="n">assert</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="s2">&quot;shopping&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="ss">:error</span>
<span class="k">end</span>
</code></pre></div>
<p>The test is similar to &quot;removes bucket on exit&quot; except that we are being a bit more harsh. Instead of using <code>Agent.stop/1</code>, we are sending an exit signal to shutdown the bucket. Since the bucket is linked to the registry, which is then linked to the test process, killing the bucket causes the registry to crash which then causes the test process to crash too:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1) test removes bucket on crash (KV.RegistryTest)
   test/kv/registry_test.exs:52
   ** (EXIT from #PID&lt;0.94.0&gt;) shutdown
</code></pre></div>
<p>One possible solution to this issue would be to provide a <code>KV.Bucket.start/0</code>, that invokes <code>Agent.start/1</code>, and use it from the registry, removing the link between registry and buckets. However, this would be a bad idea, because buckets would not be linked to any process after this change. This means that if someone stops the <code>kv</code> application, all buckets would remain alive as they are unreachable.</p>

<p>We are going to solve this issue by defining a new supervisor that will spawn and supervise all buckets. There is one supervisor strategy, called <code>:simple_one_for_one</code>, that is the perfect fit for such situations: it allows us to specify a worker template and supervise many children based on this template.</p>

<p>Let&#39;s define our <code>KV.Bucket.Supervisor</code> as follows:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">KV.Bucket.Supervisor</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="nc">Supervisor</span>

  <span class="kd">def</span> <span class="n">start_link</span><span class="p">(</span><span class="n">opts</span> <span class="p">\\</span> <span class="p">[])</span> <span class="k">do</span>
    <span class="nc">Supervisor</span><span class="p">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="ss">:ok</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">start_bucket</span><span class="p">(</span><span class="n">supervisor</span><span class="p">)</span> <span class="k">do</span>
    <span class="nc">Supervisor</span><span class="p">.</span><span class="n">start_child</span><span class="p">(</span><span class="n">supervisor</span><span class="p">,</span> <span class="p">[])</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">init</span><span class="p">(</span><span class="ss">:ok</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">children</span> <span class="p">=</span> <span class="p">[</span>
      <span class="n">worker</span><span class="p">(</span><span class="nc">KV.Bucket</span><span class="p">,</span> <span class="p">[],</span> <span class="ss">restart</span><span class="p">:</span> <span class="ss">:temporary</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">supervise</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="ss">strategy</span><span class="p">:</span> <span class="ss">:simple_one_for_one</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>There are two changes in this supervisor compared to the first one.</p>

<p>First, we define a <code>start_bucket/1</code> function that will receive a supervisor and start a bucket process as a child of that supervisor. <code>start_bucket/1</code> is the function we are going to invoke instead of calling <code>KV.Bucket.start_link</code> directly in the registry.</p>

<p>Second, in the <code>init/1</code> callback, we are marking the worker as <code>:temporary</code>. This means that if the bucket dies, it won&#39;t be restarted! That&#39;s because we only want to use the supervisor as a mechanism to group the buckets. The creation of buckets should always pass through the registry.</p>

<p>Run <code>iex -S mix</code> so we can give our new supervisor a try:</p>
<div class="highlight"><pre><code class="language-iex" data-lang="iex"><span class="gp">iex&gt; </span><span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">sup</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Bucket.Supervisor</span><span class="p">.</span><span class="n">start_link</span>
<span class="go">{:ok, #PID&lt;0.70.0&gt;}</span>
<span class="gp">iex&gt; </span><span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">bucket</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Bucket.Supervisor</span><span class="p">.</span><span class="n">start_bucket</span><span class="p">(</span><span class="n">sup</span><span class="p">)</span>
<span class="go">{:ok, #PID&lt;0.72.0&gt;}</span>
<span class="gp">iex&gt; </span><span class="nc">KV.Bucket</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="s2">&quot;eggs&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">:ok</span>
<span class="gp">iex&gt; </span><span class="nc">KV.Bucket</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="s2">&quot;eggs&quot;</span><span class="p">)</span>
<span class="go">3</span>
</code></pre></div>
<p>Let&#39;s change the registry to work with the buckets supervisor. We are going to follow the same strategy we did with the events manager, where we will explicitly pass the buckets supervisor pid to <code>KV.Registry.start_link/3</code>. Let&#39;s start by changing the setup callback in <code>test/kv/registry_test.exs</code> to do so:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">setup</span> <span class="k">do</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">sup</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Bucket.Supervisor</span><span class="p">.</span><span class="n">start_link</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">manager</span><span class="p">}</span> <span class="p">=</span> <span class="nc">GenEvent</span><span class="p">.</span><span class="n">start_link</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">registry</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Registry</span><span class="p">.</span><span class="n">start_link</span><span class="p">(</span><span class="n">manager</span><span class="p">,</span> <span class="n">sup</span><span class="p">)</span>

  <span class="nc">GenEvent</span><span class="p">.</span><span class="n">add_mon_handler</span><span class="p">(</span><span class="n">manager</span><span class="p">,</span> <span class="nc">Forwarder</span><span class="p">,</span> <span class="n">self</span><span class="p">())</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="ss">registry</span><span class="p">:</span> <span class="n">registry</span><span class="p">}</span>
<span class="k">end</span>
</code></pre></div>
<p>Now let&#39;s change the appropriate functions in <code>KV.Registry</code> to take the new supervisor into account:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="c1">## Client API</span>

<span class="na">@doc</span> <span class="sh">&quot;&quot;&quot;</span>
<span class="sh">Starts the registry.</span>
<span class="sh">&quot;&quot;&quot;</span>
<span class="kd">def</span> <span class="n">start_link</span><span class="p">(</span><span class="n">event_manager</span><span class="p">,</span> <span class="n">buckets</span><span class="p">,</span> <span class="n">opts</span> <span class="p">\\</span> <span class="p">[])</span> <span class="k">do</span>
  <span class="c1"># 1. Pass the buckets supervisor as argument</span>
  <span class="nc">GenServer</span><span class="p">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="p">{</span><span class="n">event_manager</span><span class="p">,</span> <span class="n">buckets</span><span class="p">},</span> <span class="n">opts</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1">## Server callbacks</span>

<span class="kd">def</span> <span class="n">init</span><span class="p">({</span><span class="n">events</span><span class="p">,</span> <span class="n">buckets</span><span class="p">})</span> <span class="k">do</span>
  <span class="n">names</span> <span class="p">=</span> <span class="nc">HashDict</span><span class="p">.</span><span class="n">new</span>
  <span class="n">refs</span>  <span class="p">=</span> <span class="nc">HashDict</span><span class="p">.</span><span class="n">new</span>
  <span class="c1"># 2. Store the buckets supervisor in the state</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">%{</span><span class="ss">names</span><span class="p">:</span> <span class="n">names</span><span class="p">,</span> <span class="ss">refs</span><span class="p">:</span> <span class="n">refs</span><span class="p">,</span> <span class="ss">events</span><span class="p">:</span> <span class="n">events</span><span class="p">,</span> <span class="ss">buckets</span><span class="p">:</span> <span class="n">buckets</span><span class="p">}}</span>
<span class="k">end</span>

<span class="kd">def</span> <span class="n">handle_cast</span><span class="p">({</span><span class="ss">:create</span><span class="p">,</span> <span class="n">name</span><span class="p">},</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">if</span> <span class="nc">HashDict</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">state</span><span class="p">}</span>
  <span class="k">else</span>
    <span class="c1"># 3. Use the buckets supervisor instead of starting buckets directly</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">pid</span><span class="p">}</span> <span class="p">=</span> <span class="nc">KV.Bucket.Supervisor</span><span class="p">.</span><span class="n">start_bucket</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">buckets</span><span class="p">)</span>
    <span class="n">ref</span> <span class="p">=</span> <span class="nc">Process</span><span class="p">.</span><span class="n">monitor</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
    <span class="n">refs</span> <span class="p">=</span> <span class="nc">HashDict</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">refs</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">names</span> <span class="p">=</span> <span class="nc">HashDict</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">pid</span><span class="p">)</span>
    <span class="nc">GenEvent</span><span class="p">.</span><span class="n">sync_notify</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">events</span><span class="p">,</span> <span class="p">{</span><span class="ss">:create</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">pid</span><span class="p">})</span>
    <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="p">%{</span><span class="n">state</span> <span class="p">|</span> <span class="ss">names</span><span class="p">:</span> <span class="n">names</span><span class="p">,</span> <span class="ss">refs</span><span class="p">:</span> <span class="n">refs</span><span class="p">}}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Those changes should be enough to make our tests pass! To complete our task, we just need to update our supervisor to also take the buckets supervisor as child.</p>

<h2 id="5.4-supervision-trees">5.4 Supervision trees</h2>

<p>In order to use the buckets supervisor in our application, we need to add it as a child of <code>KV.Supervisor</code>. Notice we are beginning to have supervisors that supervise other supervisors, forming so-called &quot;supervision trees.&quot;</p>

<p>Open up <code>lib/kv/supervisor.ex</code>, add an additional module attribute for the buckets supervisor name, and change <code>init/1</code> to match the following:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="na">@manager_name</span> <span class="nc">KV.EventManager</span>
<span class="na">@registry_name</span> <span class="nc">KV.Registry</span>
<span class="na">@bucket_sup_name</span> <span class="nc">KV.Bucket.Supervisor</span>

<span class="kd">def</span> <span class="n">init</span><span class="p">(</span><span class="ss">:ok</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">children</span> <span class="p">=</span> <span class="p">[</span>
    <span class="n">worker</span><span class="p">(</span><span class="nc">GenEvent</span><span class="p">,</span> <span class="p">[[</span><span class="ss">name</span><span class="p">:</span> <span class="na">@manager_name</span><span class="p">]]),</span>
    <span class="n">supervisor</span><span class="p">(</span><span class="nc">KV.Bucket.Supervisor</span><span class="p">,</span> <span class="p">[[</span><span class="ss">name</span><span class="p">:</span> <span class="na">@bucket_sup_name</span><span class="p">]]),</span>
    <span class="n">worker</span><span class="p">(</span><span class="nc">KV.Registry</span><span class="p">,</span> <span class="p">[</span><span class="na">@manager_name</span><span class="p">,</span> <span class="na">@bucket_sup_name</span><span class="p">,</span> <span class="p">[</span><span class="ss">name</span><span class="p">:</span> <span class="na">@registry_name</span><span class="p">]])</span>
  <span class="p">]</span>

  <span class="n">supervise</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="ss">strategy</span><span class="p">:</span> <span class="ss">:one_for_one</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>This time we have added a supervisor as child and given it the name of <code>KV.Bucket.Supervisor</code> (again, the same name as the module). We have also updated the <code>KV.Registry</code> worker to receive the bucket supervisor name as argument.</p>

<p>Also remember that the order in which children are declared is important. Since the registry depends on the buckets supervisor, the buckets supervisor must be listed before it in the children list.</p>

<p>Since we have added more children to the supervisor, it is important to evaluate if the <code>:one_for_one</code> strategy is still correct. One flaw that shows up right away is the relationship between registry and buckets supervisor. If the registry dies, the buckets supervisor must die too, because once the registry dies all information linking the bucket name to the bucket process is lost. If the buckets supervisor is kept alive, it would be impossible to reach those buckets.</p>

<p>We could consider moving to another strategy like <code>:one_for_all</code>. The <code>:one_for_all</code> strategy kills and restarts all children whenever one of the children die. This change is not ideal either, because a crash in the registry should not crash the event manager. In fact, doing so would be harmful, as crashing the event manager would cause all installed event handlers to be removed.</p>

<p>One possible solution to this problem is to create another supervisor that will supervise the registry and buckets supervisor with <code>:one_for_all</code> strategy, and have the root supervisor supervise both the event manager and the new supervisor with <code>:one_for_one</code> strategy. The proposed tree would have the following format:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">* root supervisor [one_for_one]
  * event manager
  * supervisor [one_for_all]
    * buckets supervisor [simple_one_for_one]
      * buckets
    * registry
</code></pre></div>
<p>You can take a shot at building this new supervision tree, but we will stop here. This is because in the next chapter we will make changes to the registry that will allow the registry data to be persisted, making the <code>:one_for_one</code> strategy a perfect fit.</p>

<p>Remember, there are other strategies and other options that could be given to <code>worker/2</code>, <code>supervisor/2</code> and <code>supervise/2</code> functions, so don&#39;t forget to check out <a href="/docs/stable/elixir/Supervisor.html">the Supervisor module documentation</a>.</p>

  </article><!-- .hfeed -->

  
</div><!-- #content -->


  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-8268430-6']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <script src="/js/toc/toc.js" type="text/javascript" charset="utf-8"></script>
  <script type="text/javascript">
    $(document).ready(function() {
        $('.toc').toc({
          title: '',
          listType: 'ul',
          minimumHeaders: 2,
          headers: 'h2, h3, h4, h5, h6',
          showSpeed: 0,
        });
    });
  </script>
</body>
</html>

